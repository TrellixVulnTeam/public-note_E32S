一、表、栈和队列
	抽象数据类型，是带有一组操作的一些对象集合。就是数学的抽象。比如最贱的Integer就是一个抽象数据类型，它表示类【整数】这一类数，也就是整数的抽象。
	1.Java Collections API中的ADT
		1).Collection接口
			有一组简单的操作:
				public interface Collection<T> extends Iterable<T>{
					int size();			//返回项的个数
					boolean isEmpty();	//个数为0返回true，否则false
					void clear();		//清空
					boolean contains(T x);	//判断x是否包含在集合当中
					boolean add(T x);		//添加操作，若成功返回true，非抛出异常的失败返回false，比如插入重复项可以让add返回false
					boolean remove(T x);	//删除操作，若成功返回true，非抛出异常的失败返回false，比如删除不存在的项可以让remove返回false
					Iterator<T> iterator();	//迭代器
				}
		2).Ierator接口
			通过iterator方法，每个集合均可以创建并返回客户一个实现Iterator接口的UI想，并将【当前位置】的概念在对象内部存储起来。可以通过调用next遍历集合。
			next返回的是下一项。Iterator接口提供简洁的操作。
				public interface Iterator<T>{
					boolean hasNext();
					T next();
					void remove();
				}
			iterator的remove方法非常好用，
				一方面，collection的remove需要找到对象的具体位置才能删除(比如linkedlist的remove)，但使用iterator是已经保存了最近位置的。
				一方面，使用iterator时，若对collection对象用了remove add等改变结构的方法， 那么iterator将会失效，切抛出ConcurrentModificationException异常。而使用自带的remove方法不会有影响。
		3).List接口
			public interface List<T> extends Collection<T>{
				T get(int idx);
				T set(int idx, T nv);
				void add(int idx, T x);
				void remove(int idx);
			}
			具体说来，list提供了在指定索引上进行操作的方法，而collection是没有索引操作的，collection只能保证对象放在了集合中或是从集合中删除了。
			list翻译过来就是表，表很明显需要索引操作的。
		4).ListIterator接口
			public interface LiistItertor<T> extends Iterator<T>{
				boolean hasPrevious();
				T previous();
				
				void add(T x);
				void set(T nv);
			}
	2.内部类和嵌套类
		java结构支持嵌套类和内部类，嵌套类和内部类都指在class中再定义一个class。
		1).嵌套类
			static class就是嵌套类，它就是一个类和对象是无关的。它和其外部class相对独立，只是表示结构关系而把它放在里面。
			如LinkedList的Node类，就是一个嵌套类。Node类仅由LinkedList类使用，因此还是private的。
		2).内部类
			不加static的class就是内部类，它是和外部class实例相关的，并依赖其生存。
			内部类是可以使用外部类的实例域的，因为它和外部类的实例是相关联的。外部类的名字若为Outer，则在内部类中用Outer.this来应用外部类的实例。
			内部类对象只能由实例方法(非static)来实例化，因为这样才能和进行实例化的那个外部类对象建立关联。
	3.ArrayList和LinkedList类的实现
		过于简单就不提了。
	4.栈的应用
		栈用ArrayList或是LinkedList来实现，都是非常高效的。
		1).平衡符号
			检查一段代码中的{[()]}等成对出现符号的对称问题。
			出现左符号，如{、[、(。那么将入栈。若出现右符号，就检查栈顶是否为对应的左符号，是则出栈，不是那么不对称，抛出异常。
		2).后缀表达式
			后缀表达式，又称逆波兰记法。
			计算方法非常简单，遇到一个数字就将数字入栈，遇到操作符就将两个数字出栈并将计算结果再入栈。
		3).中缀到后缀的转换
			这个稍微麻烦一些。
			从左往右扫描表达式，遇到数字就输出，遇到操作符就判断栈中是否有优先级高的操作符，若有则将优先级高的操作符出栈直到同级操作符出现。
			遇到左括弧，则将左括弧进栈，左括弧在栈里是等级最低的，因此除非遇到右括弧其不会出去。当遇到右括弧，将左括弧之前的符号全部输出。左括弧弹出但不输出。
			
二、树
	对于大量的输入数据，链表的线性访问时间太慢，因此常用二叉查找树(binary search tree)。这是TreeSet和TreeMap实现的基础。大部分操作的时间复杂度平均为o(logN)
	1.基础知识
		【树】，就是一个节点，该节点上可以有多个非空的子树，也可以为空。
		【树叶】，没有子节点的节点，也称为叶节点。
		【兄弟】，具有相同父亲节点的节点之间称为兄弟。
		【路径】，从节点n1到nk的路径为其所经过的节点序列n1 n2 n3 ... nk
		【长】，路径上的边数。自己到直接的长为0，因为0条边。
		【深度】，节点ni的深度为从根到ni的唯一的路径的长。因此根的深度为0。
		【高度】，节点ni的高度是ni到【最远】叶节点的长。
		【祖先】，若n1到n2存在一条路径，那么n1是n2的祖先。
	2.树的实现
		节点上出来数据外，还应该有到子节点的连接集合，当然这个集合可以用数组，也可以用链表。通常用的二叉树，因此可以放置直接的连接。但注意，若是多叉树，应该考虑用链表。
		class Treeode{
			Object element;
			TreeNode firstChild;
			TreeNode nextSibling;
		}
	3.树的遍历
		1)先序遍历
			对节点的处理工作是在对子节点遍历之前进行的。比如一个打印目录树中所有目录名和文件名的程序，为了更好的显示目录的级别，应该先打印出当前的目录然后在递归打印其子目录和子节点。
			void process(){
				processNode(node);
				for(Node child:node.children){
					process(child);
				}
			}
		2).后序遍历	
			顾名思义，节点的处理工作是再对子节点遍历完成之后进行的。这个蛮常用的，经常都要先计算出子节点的情况再来计算当前节点的情况。比如打印每个目录中中文件的个数，只有先递归计算出所有子目录中的文件数才能计算出当前目录中的文件数。
			void process(){
				for(Node child:node.children){
					process(child);
				}
				processNode(node);
			}
		3).中序遍历
			中序遍历通常针对二叉树类型的结构，先遍历左子树，然后处理当前节点，最后遍历右子树。这个并不常用。比如可以根据表达式数，生成表达式的中缀表示。
			void process(){
				process(node.left);
				processNode(node);
				process(node.right);
			}
		4).层序遍历
			这个更为特殊，前面3种遍历方式都属于深度优先搜索，这个属于广度优先搜索。所有深度为d的节点要在d+1的节点之前进行处理。不是递归的，一般使用队列。
			void process(){
				queue.enqueue(root);
				while(!queue.isEmpty()){
					Node node = queue.dequeue();
					processNode(node);
					for(Node child:node.children){
						process(child);
					}
				}
			}
	4.二叉查找树(binary search tree)
		1).二叉树
			每个节点都不能有多于两个子节点的树。
			class BinaryNode{
				Object element;
				BinaryNode left;
				BinaryNode right;
			}
		2).二叉查找性质
			首先，得是一个二叉树
			其次，满足左子树中的所有项的值小于本节点，右子树中的所有项的值大于本节点。
		3).二叉查找树类
			public class BinarySearchTree<T extends Comparable<? super T>>{
				private BinaryNode<T> root;
				
				public BinarySerachTree(){
					root = null;
				}
				/**
				 * 对外开放的公共方法
				 */
				public void makeEmpty();
				public boolean isEmpty();
				public boolean contains(T x);
				public T findMin();
				public T findMax();
				public void insert(T x);
				public void remove(T x);
				public void printTree();
				
				/**
				 * 节点类
				 */
				private static class BinaryNode<T>{
					T element;
					BinaryNode<T> left;
					BinaryNode<T> right;
					
					BinaryNode(T theElement){
						this.BinaryNode(theElement, null, null);
					}
					
					BinaryNode(T theElement, BinaryNode<T> lt, BinaryNode<T> rt){
						element = theElement;
						left = lt;
						right = rt;
					}
				}
			}
			
			这里需要强调一下<T extends Comparable<? super T>>这个结构，这个结构说的是泛型T应该继承了Comparable这个泛型类。
			而Comparable这个泛型类中的类型，应该是T的父类。
			这是因为若某个类实现了泛型类，class A implements Comparable<A>类，那么其子类clas B extends A，B类实现的是Comparable<A>，而不是Comparable<B>。
			因此Comparable<? super T>正是为了应对B类的情况。
			总之<T extends Comparable<? super T>>，意味输入的类型T实现了Comparable泛型类，且Comparable泛型类的参数类型是T或者其父类。
		4).个别方法的实现
			contains、findMin、findMax都非常简单。
			a).insert方法
				这个只需要找到插入的位置即可，但是不做平衡容易降低查询效率。
				还有个比较特别的是，对于重复插入，可以在节点中保留一个附加于以指示发送的频率。不过一般都是将旧的覆盖掉。
				普通的插入，都会插入到叶节点。简单来说
					和当前节点的大小相比，若值小于当前节点，则插入到左子树中。若大于当前节点，则插入到右子树中。直至插入到叶节点上。
			b).remove方法
				删除通常考虑采用懒惰删除，当一个元素要被删除时，并不实际将其删除，而是标记其为删除。更广泛的来说，可以留一个附加的域指明该对象元素的个数，这样insert和remove方法直接就在其个数上操作。
				不过，往往我们也要实际删除的，实际的方法是：
					删除节点为叶节点，直接置为null。
					删除节点有一个节点，将该节点给其父节点。
					删除节点有两个节点，将右节点最小的节点置为该节点，然后再删除右节点中最小的节点(就是删掉刚刚换过去的那个节点)。
		5).AVL树
			AVL是三个人的名字，这是一个带有平衡条件的二叉查找树。
			理想的平衡树，平衡条件要求左子树和右子树具有相同的高度，这太过于严格。
			AVL树，其平衡条件要求左子树和右子树的高度最多差为1。
			AVL树，除去插入和删除外，所有的方法都可以以时间O(logN)执行，当插入和删除时，需要更新根节点路径上那些节点的所有平衡信息。插入和删除可能会破坏AVL的树平衡状态。
			a).旋转
				对于一个节点a，会造成不平衡的插入主要体现在以下4种情况:
					i).对a的左儿子的左子树进行一次插入
					ii).对a的左儿子的右子树进行一次插入
					iii).对a的右儿子的左子树进行一次插入
					iv).对a的右儿子的右子树进行一次插入
				i和iv是镜像的, 采用单旋转。
				ii和iii是镜像的，采用双旋转。
				(1).单旋转
					单旋转的情况比较近简单，既然节点a不平衡了，不是左边高了，就是右边高了，只需要将高的那边往上一提，矮的那边往下一按，这样相对高度就没有了。
				(2).双旋转
					这种情况，因为是内部的树过高，内部的是不能简单一次性提起来的。而是需要将内部的树又分为左右子树，将这两棵树往上面接。相当于要做两次单旋转。
				旋转不是很容易描述，具体看图和程序。
			b).avl部分实现
				private static class AvlNode<T>{
					T element;
					AvlNode<T> left;
					AvlNode<T> right;
					int height;
					
					AvlNode(T e){this(e, null, null);}
					AvlNode(T e, AvlNode<T> lt, AvlNode<T> rt){
						element = e;
						left = lt;
						right = rt;
					}
				}
				(1).插入
					插入子节点后，判断当前节点是否需要平衡，不平衡就旋转。根据子节点的情况来进行旋转的选择。
					先判断左右子节点哪边高，高的那边就是有新的子节点插入。假如左节点的树更高，然后判断左节点中的左子树和右子树中哪个更高，就可以判断是插入的左左还是左右。另一边同理。
					对于具体的编程来说，只需要实现普通的二叉查找树的插入，然后判断当前节点是否平衡，不平衡则旋转。
				(2).删除
					删除只需要实现普通二叉查找树的删除，然后判断当前节点是否平衡，不平衡就调整。
	5.Btree
		B树常在数据库等技术中使用，若将一个map存储在磁盘中，由于磁盘读写的缓慢会带来大量的延迟。另外，保存在磁盘上的，一般都是大量的数据，例如1kw个entry。若将key通过avl树的形式保存，深度最深有log1kw层，大约是25。因此最坏的情况会读写25次磁盘，读写次数过多，非常缓慢。
		很明显，只要将层数降低，就能避免最坏情况带来的大延迟。avl树已经非常接近完全平衡的二叉树了，因此二叉树是不能完成该任务的。只能用多叉树。
		1).M阶的B数具有以下特点:
			a).数据存储在叶节点上。(非叶结点不保存数据，仅保存关键词)
			b).非叶节点上可以保存的关键词个数<=M-1
			c).根节点要么全是叶节点，要么是[2, M]个子节点。
			d).非根非叶的节点，其子节点个数范围是[M/2, M]。
			e).所有的输液都在相同的深度上存在[L/2, L]个数范围内的数据项。
			另外，关键词的特性是，节点上的关键词i，是该节点i+1子树中的最小值。很明显，B树是通过比较关键词大小来进行子节点选择的。
		2).M和L的计算
			每个节点代表一个磁盘区块，意思就是说，要调整L和M，使每个节点的大小可以容纳与一个磁盘区中。
			现在设1个关键词大小为keyBytes，1个值大小为valueBytes，一个区块大小为blockSize。
				一个key节点上有M-1个关键词，那么一个关键词节点占大小(M-1)*keyBytes，那么有M = blockSize/keyBytes + 1。
				一个value节点上上有L个数据项，那么一个value节点占大小valueBytes*L，那么有L = blockSize/valueBytes。
				最坏的情况是logN / log(M/2)
		3).算法
			对应的插入和取出算法就不给出了。取出相对简单，插入需要进行平衡的调整。
三、优先队列(堆)
	优先队列 允许至少两种操作:
		insert(插入)，相当于入队。
		deleteMin(删除最小者)，找出，返回并删除优先队列中最小的元素。
	1.简单实现
		1).简单链表
			insert，在表头以O(1)的执行插入操作。
			deleteMin，需要查找出最小的元素并删除，需要O(N)时间。
		2).二叉查找树
			insert，只需要按正常的方式进行即可。
			deleteMin，需要一直找最left的节点。
			就算不做平衡，查找树的效率也蛮高的，因为没有查找操作(平衡是为了查找操作)。
	2.二叉堆
		1)性质:
			* 结构型
				是一颗完全填满的二叉树，底层上的元素从左到右填入。
				由于满足结构型，因此可以用数组来表示。
				[极小值][A][B][C][D]...[]
				元素从数组下标1开始。
				坐标i的元素，父元素的坐标是i/2并向下取整。
				左儿子，坐标是2*i，右儿子的坐标是2*i+1。
			* 堆序性
				堆的最小元素应该在根上，且任意子树都是堆。
		2).基本操作
			* insert
				插入，先将节点放在树的末尾，然后通过和父节点进行比较，若小于父节点就把该节点和父节点交换。一直和父节点作比较，小于父节点就交换。
				很明显，这是一个从下到上的过程，也叫作上滤。
			* deleteMin
				直接将根元素返回，这样根元素就空了，将子节点中最小的放到根上来，空的节点一直用子节点的小值来代替，一直到叶节点替换为空，将最后的一个元素放到空的叶节点上来。
				很明显，这是一个从上到下的过程，也叫作下滤。
		3).其他操作
			* 降低元素的值(优先级提高)
				通过对改变节点进行上滤来实现。
			* 增大元素的值(优先级降低)
				通过对改变节点进行下滤来实现。
			* 删除p位置的元素
				只需要降低p位置元素的值，将其上滤到根，然后再将其deleteMin。
	3.d堆
		堆的插入操作，有个上滤过程，因此二叉树的高度决定了其复杂度。当使用多叉树时，可以降低高度，进一步降低插入的复杂度。
		d堆是一个所有节点有d个子节点的堆，insert操作的运行时间为O( logd(N) )。
		虽然树浅了，上滤操作很方便，但是下滤操作边麻烦了，因为每个节点都有个找出最小子节点的过程，因此一个取出操作的复杂度为O(dlogd(N))
	4.左式堆
		左式堆具有二叉堆的堆序性，但具有和二叉堆不同的结构型。
		左式堆的性质是：对于堆中的每一个节点X，npl(x.left) >= npl(x.right)。
		npl(x)，称为x的零路径长，就是x到不具有两个儿子的节点的最短路径。似乎可以翻译成就是x到叶节点上的最短路径。
		由于左式堆具有npl(x.left)>=npl(x.right)的性质，因此偏重于树的左边会比较“重”。
		1.合并
			将两个堆合并，需要将大根值的树和小根值的右子树进行合并，合并的新树作为小根值节点的右子树。然后若此时新的右子树npl大于左子树，那么交换左右子树。
		2.基本原理
			左式堆的合并操作的结果，总会倾向于右子树深度，多次合并操作，或许会造成右子树太深，因此在社当的时候应该进行左右子树的交换。
			这个适当时候，就是右节点的npl大于左节点的npl时，左右节点交换。
四、排序(升序)
	1.选择法排序
		基本思想是 每次遍历数组选择最小的值，然后将该值放到最前面。
		更进一步，第i次遍历，选择r[i+1]~r[n-1]中的最小值，并与r[i]进行交换，直至全部完毕。
		时间复杂度为O(n^2)
	2.冒泡法排序
		基本思想是 比较相邻两元素，如果第一个比第二个大，就交换他们。
		更进一步，每次都开始第一对数到最后一对数的上述操作，这称为1次冒泡。可以确定的是第i次冒泡，r[n-i]~r[n-1]的排序肯定是正确的。一直冒泡，没有元素交换为止。
		时间复杂度为O(n^2)
	3.插入法排序
		基本思想是维护了一个排序集合，每次从数组中选择1个元素插入到集合中进行排序，直至数组中的元素全部都放进集合为止。
		实现上来说要更明智一些，认为索引i前的元素已经排序完毕，这是将索引i处的的元素和前面的1个元素进行比较，若比前面的1个元素小就交换，直至不能再向前交换为止，这样就把i+1前的元素排序完毕。将i从1起一直进行该操作知道i遍历到最后。
		时间复杂度为O(n^2)
		void insertionSort(AnyType[] a){
			int j;
			for(int p=1; p<a.length; p++){
				AnyType tmp = a[p];
				for(j=p; j>0 && tmp.compareTo(a[j-1])<0; j--){
					a[j]=a[j-1];
				}
				a[j]=tmp;
			}
		}
	4.希尔排序
		shell排序，使用一个h[1], h[2], ..., h[t]增量序列，只要h[1]=1，任何增量序列都是合法的。
		在使用增量h[k]的一趟排序后，对于每一个i我们都有a[i]<=a[i+h[k]]，即相隔h[k]的元素都被排序了，这叫做h[k]的排序性。并且需要确定的是h[k]排序后，后面的h[k-1] h[k-2]的排序都不会影响h[k]的拍序性。
		而一次h[k]排序，就是对h[k]个独立的子数组进行插入排序。
		时间复杂度为O(n^1.3)
	5.堆排序
		堆排序为了优化空间复杂度，没有直接使用优先队列。若是要升序，则需要选择用极大堆。
		由于极大堆也就是一个数组，每次将根元素删除，并调整堆的数组结构后，将刚删除的对元素放到数组的最后。一直进行该操作，知道排序完成。
		时间复杂度为O(nlogn)
	6.归并排序
		这是java泛型标准库api采用的排序方法。
		基本思想是，将一次排序分为对左半和右半的排序，在左半右半排序完成后，再通过简单的方式将两个排序结果融合为1个排序结果。而对左半和右半的排序仍然可以使用该方法，因此形成了一个递归调用。
		排序结果融合的方式是将两个序列的首元素进行比较，并且将其中最小的从序列中删除并输出到排序结果中，一直如此直到排序完成。
		时间复杂度为O(nlogn)
	7.快速排序
		c++的stl采用的排序方法。
		基本思想是选取数组中的一个数，称为枢纽元。将数组中比枢纽元小的数分为1组，比枢纽元大的数分为1组，然后将这两组排序。排序得到两组数，可以直接拼接得到最终排序结果。
		枢纽元的选取方案；三数中值分割法，即选取左端 右端 中心位置上的3个元素的中值作为枢纽元。
	8.外部排序
		磁盘中可以存储的数据远大于内存，为了对磁盘中的海量数据进行排序，因此要使用外部排序。这里设内存可以放置的数据元素为N个。
		1).简单算法(两路合并)
			读取N个数据到内存中，进行排序并输出到磁盘中。这样可以将磁盘中的数据分为M组，每组N个元素的顺串保存到磁盘中。
			然后可以进行顺串的合并，两两长度为N的顺串合并后得到M/2组长度为2*N的顺串，按同样的方法再次进行排序，直到只有1组顺串为止。
			顺串合并采用归并排序是所用的合并方案。
		2).多路合并
			借鉴上述的方案，在得到初始的M组顺串后，使用k组顺串合并的方案，这样可以减少合并的次数，但是为了得到k个数的最小值会比2路的多花些时间。
		3).多相合并
			多相合并主要是为了节约磁盘空间。不展开。
		4).替换选择
			多路合并的方案需要读入N个元素到内存，然后输出一个长度为N的顺串。后面的合并操作主要受顺串的个数影响。
			为了进一步减小顺串的个数，可以考虑增大一个顺串的长度。
			N个元素读入到内存中并建立一个优先队列，执行一次deleteMin，把最小的元素输出到磁盘中。然后再读入一个元素到内存，若是比刚刚输出的元素大则将其入堆，若是比刚刚的输出元素小，则让它进死区，因为刚刚已经输出了比这个元素大的了，不能输出新加入的元素到磁盘中。
			一直如此，直到队列中没有元素时，便输出了一个顺串。此时死区已满，将死区中的数据重建堆，进行新的顺串输出。
	9.排序总结
		1.时间复杂度
		2.稳定性
			稳定的排序对于相同的元素不会进行位置交换。
			1).冒泡法，稳定。
				冒泡法将相邻元素进行比较，若元素相同的时候是不会进行交互的。所以相同元素的顺序不会发生变化，是稳定的。
			2).插入法，稳定。
				插入法是将比新元素小的元素一个一个向右移动，当遇到相同元素或更小的元素时将立即停止，会将新元素放在该元素的后面。因此是稳定的。
			3).归并法，稳定。
			
			4).选择法，不稳定
				有一个重复出现的值，其中第一个值出现在前面，当其被替换到后面的时候，可能被放到其他同值元素的后面。因此不稳定。
			5).快速排，不稳定。
				快排不稳定性的来源主要是对于枢纽元的交互。
				每次选取完枢纽元，都会将枢纽元放在倒数第二个位置，并且每次完成一套快排，都需要将想右的指针所指向的元素和枢纽元进行一次交换，这可能打乱原本的顺序。
			6).堆排序，不稳定。
			7).希尔法，不稳定。