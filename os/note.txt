一、进程描述和控制
	1.进程的状态
		1).两状态模型
			这是最基本的进程状态：运行态 和 未运行态
			当前在运行的进程在一定时间后被中断，操作系统的分派器部分将选择一个新进程运行：
			---创建进程---> 非运行态队列 ---调度---> 运行 ---退出--->
			                  /|\                     |
							   |----------------------|
			创建进程以及当前进程的的暂停都会将进程送到非运行态队列中，当前进程暂停或退出后，将会从队列中选择一个新的进程运行。
		2).五状态模型
			五状态：
				运行态: 该进程真正执行。
				就绪态: 该进程做好了准备，只要有机会就开始执行。
				阻塞态: 进程在某些事件发生前半年执行，如io操作完成。
				新建态: 刚刚创建的进程，操作系统还没有将它加入到可执行进程组中。通常是PCB已经创建，但是还没有加载到内存中的新警察。
				退出态: 操作系统从可执行进程组中释放出的进程。
			两状态模型太过简单，非运行态的进程可能并不是因为时间片的原因而暂停，还可能因为io操作这样的行为被阻塞。
			更具体的说，存在一些进程已经准备好，一些进程因为io操作而没有准备好，这些都是非运行态的。
			因此将非运行态分为就绪态和阻塞态。
			具体模型：
				每一个事件都有一个队列，当前进程发生需要等待该事件时便会将进程放到对应的事件队列中，并从就绪队列中选择一个新的进程进入运行。
				当事件发生后，该事件队列中的所有进程将会放到就绪态队列中。
				---新建进程---> 就绪队列 ---调度---> 运行 ------|---释放--->
				                  /|\                  |        |
								   |---------超时------|        |
								   |                            |
								   |<---发生事件1-- 事件1队列 --|
								   |                            |
								   |<---发生事件2-- 事件2队列 --|
								   |                            |
								   |<---发生事件3-- 事件3队列 --|
		3).七状态模型
			当内存中进程过多时，新建的进程不会被放到内存中来。当发生极端情况，内存中的进程过多，并且这些进程都在等待事件，此时就绪队列中是空的，cpu无法运行进程。
			这样会导致cpu空出没有任务执行，而此时又有新建的进程。效率将会降低。可以考虑采用swap将部分进程转换到磁盘中去。在磁盘中放置的进程就被称为：【挂起态】。
			当内存中的所有进程都处于阻塞态时，就会把其中一个进程挂起(转换到磁盘中)，这样释放出内存空间方便新建态的进程加载到内存中去。
			单单是增加挂起态，也没有办法完全解决问题，因为挂起态都是由于需要等待某个事件，因此没法确定挂起态何时被换入到内存中，这需要将挂起态分割为【阻塞/挂起】和【就绪/挂起】
			状态转换:
				  阻塞    ---> 阻塞/挂起：当没有就绪进程或就绪进程需要更多的内存空间，则至少一个阻塞经常被换出，为另一个没有阻塞的进程让车空间。
				阻塞/挂起 ---> 就绪/挂起：当阻塞/挂起的进程所等待的事件发生了，则转换。
				就绪/挂起 --->   就绪   ：当就绪队列空时将会发生这样的情况。
				  就绪    ---> 就绪/挂起：当高优先级的挂起进程需要执行，而就绪态里面是一个低优先级的进程，就可能发生这样的操作。或是需要更多的内存，但是阻塞态已经没有可以挂起的时候也会有这样的情况。
	2.进程描述
		操作系统为了管理进程和资源，必须掌握关于每个进程和资源当前状态的信息。操作系统构造并维护它所管理每个实体的信息表：
		内存---->内存表
		设备---->IO表
		文件---->文件表
		进程---->进程1表--->进程2表--->进程3表--->...
		            |          |          |
				   \|/        \|/        \|/
				 进程映像   进程映像   进程映像
		1).进程控制结构
			a).进程的位置
				程序，数据，栈，进程控制块 这些被称为【进程映像】。
				进程表需要表明每个进程映像在内存页中的位置。
			b).进程的属性
				进程的属性主要是指在PCB中的信息。在进程状态模型中各个队列中保存的其实就是PCB的队列。
				这其中包含着 进程标识信息，进程状态信息，进程控制信息。
二、线程
	1.多线程
		1).在多线程环境中，进程被定义成资源的分配单位：
			存放进程映像的虚拟地址空间。
			受保护地对处理器，其他进程，文件和io资源的访问。
		2).在一个进程中，可能有多个线程，每个线程有：
			线程执行状态
			线程上下文(线程的控制块)
			栈空间
			每个线程局部变量的今天存储空间
			与进程内的其他线程共享对进程的内存和资源的访问
		每个线程有独立的栈和控制块用于包含寄存器值、优先级和其他线程相关的信息。
		3).线程在性能上的特点：
			创建终止快
			线程切换快
			线程通信效率高
		4).线程的状态
			运行，就绪，阻塞。
			线程没有挂起，挂起态是进程的，会将整个进程换出到磁盘。由于线程共享进程地址空间，所以相应线程也会被换出。
	2.线程分类
		主要是讨论 一个线程的阻塞，是否会影起整个进程的阻塞。
		1).用户级线程(ULT)
			有关线程的管理工作由应用程序完成，内核意识不到线程的存在。
			线程的维护，调度都是由用户代码完成，发生在单个进程内。
			优点：
				线程的切换在用户空间完成，不需要切换成内核空间，也不用从内核空间切换回用户空间。节省了开销。
				线程的调度方案可由用户自定义。
				用户线程库可以跨平台，便于移植。
			缺点：
				执行系统调用时，不仅仅这个线程会阻塞，整个进程中的所有线程都会阻塞。因为本质上还是单进程模型，由于已经阻塞此时是没办法由用户代码进行线程调度的。
				本质是单进程模型，而一个进程只会占一个处理器，因此不能通过多cpu来提升多线程的执行效率。
		2).内核级线程(KLT)
			有线程的管理工作由内核完成。内核为进程级内部的每个线程维护上下文信息，调度是由内核基于线程完成的。
			这样就能将多个线程调度到多个处理器中，并且线程被阻塞内核可以调度到进程中的另一个线程上去。
		3).用户内核混合线程
			线程的创建完全在用户空间完成，调度和同步也在应用程序中进行。一个进程中的多个用户级线程将被映射到一些内核级线程上。
三、并发性、互斥和同步
	1.进程的交互
		交互方式分类：
			- 进程相互不知道对方的存在。交互主要存在于对于同一个磁盘、文件的访问。主要是竞争关系。
			- 进程间接知道对方的存在。不知道对方的进程ID，但是知道有进程需要交互。通过共享来进行合作。
			- 进程直接知道对方的存在。通过进程通信来进行合作。
	2.信号量
		信号量的操作：
			- 一个信号量可以初始化成非负数。
			- semWait操作使信号量减1。若减一后值为负数则进程被阻塞，否则进程继续执行。
			- semSignal操作使信号量加1。若加一后值小于或等于0，则被semWait操作阻塞的进程被解除。
		二元信号量初始化为1，取值只可能是0或1。二元信号量又叫互斥量。
		semSignal会导致多个阻塞的进程其中一个被释放，若是按semWait的执行顺序释放则被称为强信号量(FIFO队列)，否则被称为弱信号量。
	3.管程
	4.消息传递
	5.读写问题
四、死锁和饥饿
	