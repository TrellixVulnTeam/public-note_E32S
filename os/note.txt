一、进程描述和控制
	1.进程的状态
		1).两状态模型
			这是最基本的进程状态：运行态 和 未运行态
			当前在运行的进程在一定时间后被中断，操作系统的分派器部分将选择一个新进程运行：
			---创建进程---> 非运行态队列 ---调度---> 运行 ---退出--->
			                  /|\                     |
							   |----------------------|
			创建进程以及当前进程的的暂停都会将进程送到非运行态队列中，当前进程暂停或退出后，将会从队列中选择一个新的进程运行。
		2).五状态模型
			五状态：
				运行态: 该进程真正执行。
				就绪态: 该进程做好了准备，只要有机会就开始执行。
				阻塞态: 进程在某些事件发生前半年执行，如io操作完成。
				新建态: 刚刚创建的进程，操作系统还没有将它加入到可执行进程组中。通常是PCB已经创建，但是还没有加载到内存中的新警察。
				退出态: 操作系统从可执行进程组中释放出的进程。
			两状态模型太过简单，非运行态的进程可能并不是因为时间片的原因而暂停，还可能因为io操作这样的行为被阻塞。
			更具体的说，存在一些进程已经准备好，一些进程因为io操作而没有准备好，这些都是非运行态的。
			因此将非运行态分为就绪态和阻塞态。
			具体模型：
				每一个事件都有一个队列，当前进程发生需要等待该事件时便会将进程放到对应的事件队列中，并从就绪队列中选择一个新的进程进入运行。
				当事件发生后，该事件队列中的所有进程将会放到就绪态队列中。
				---新建进程---> 就绪队列 ---调度---> 运行 ------|---释放--->
				                  /|\                  |        |
								   |---------超时------|        |
								   |                            |
								   |<---发生事件1-- 事件1队列 --|
								   |                            |
								   |<---发生事件2-- 事件2队列 --|
								   |                            |
								   |<---发生事件3-- 事件3队列 --|
		3).七状态模型
			当内存中进程过多时，新建的进程不会被放到内存中来。当发生极端情况，内存中的进程过多，并且这些进程都在等待事件，此时就绪队列中是空的，cpu无法运行进程。
			这样会导致cpu空出没有任务执行，而此时又有新建的进程。效率将会降低。可以考虑采用swap将部分进程转换到磁盘中去。在磁盘中放置的进程就被称为：【挂起态】。
			当内存中的所有进程都处于阻塞态时，就会把其中一个进程挂起(转换到磁盘中)，这样释放出内存空间方便新建态的进程加载到内存中去。
			单单是增加挂起态，也没有办法完全解决问题，因为挂起态都是由于需要等待某个事件，因此没法确定挂起态何时被换入到内存中，这需要将挂起态分割为【阻塞/挂起】和【就绪/挂起】
			状态转换:
				  阻塞    ---> 阻塞/挂起：当没有就绪进程或就绪进程需要更多的内存空间，则至少一个阻塞经常被换出，为另一个没有阻塞的进程让车空间。
				阻塞/挂起 ---> 就绪/挂起：当阻塞/挂起的进程所等待的事件发生了，则转换。
				就绪/挂起 --->   就绪   ：当就绪队列空时将会发生这样的情况。
				  就绪    ---> 就绪/挂起：当高优先级的挂起进程需要执行，而就绪态里面是一个低优先级的进程，就可能发生这样的操作。或是需要更多的内存，但是阻塞态已经没有可以挂起的时候也会有这样的情况。
	2.进程描述
		操作系统为了管理进程和资源，必须掌握关于每个进程和资源当前状态的信息。操作系统构造并维护它所管理每个实体的信息表：
		内存---->内存表
		设备---->IO表
		文件---->文件表
		进程---->进程1表--->进程2表--->进程3表--->...
		            |          |          |
				   \|/        \|/        \|/
				 进程映像   进程映像   进程映像
		1).进程控制结构
			a).进程的位置
				程序，数据，栈，进程控制块 这些被称为【进程映像】。
				进程表需要表明每个进程映像在内存页中的位置。
			b).进程的属性
				进程的属性主要是指在PCB中的信息。在进程状态模型中各个队列中保存的其实就是PCB的队列。
				这其中包含着 进程标识信息，进程状态信息，进程控制信息。
二、线程
	1.多线程
		1).在多线程环境中，进程被定义成资源的分配单位：
			存放进程映像的虚拟地址空间。
			受保护地对处理器，其他进程，文件和io资源的访问。
		2).在一个进程中，可能有多个线程，每个线程有：
			线程执行状态
			线程上下文(线程的控制块)
			栈空间
			每个线程局部变量的今天存储空间
			与进程内的其他线程共享对进程的内存和资源的访问
		每个线程有独立的栈和控制块用于包含寄存器值、优先级和其他线程相关的信息。
		3).线程在性能上的特点：
			创建终止快
			线程切换快
			线程通信效率高
		4).线程的状态
			运行，就绪，阻塞。
			线程没有挂起，挂起态是进程的，会将整个进程换出到磁盘。由于线程共享进程地址空间，所以相应线程也会被换出。
	2.线程分类
		主要是讨论 一个线程的阻塞，是否会影起整个进程的阻塞。
		1).用户级线程(ULT)
			有关线程的管理工作由应用程序完成，内核意识不到线程的存在。
			线程的维护，调度都是由用户代码完成，发生在单个进程内。
			优点：
				线程的切换在用户空间完成，不需要切换成内核空间，也不用从内核空间切换回用户空间。节省了开销。
				线程的调度方案可由用户自定义。
				用户线程库可以跨平台，便于移植。
			缺点：
				执行系统调用时，不仅仅这个线程会阻塞，整个进程中的所有线程都会阻塞。因为本质上还是单进程模型，由于已经阻塞此时是没办法由用户代码进行线程调度的。
				本质是单进程模型，而一个进程只会占一个处理器，因此不能通过多cpu来提升多线程的执行效率。
		2).内核级线程(KLT)
			有线程的管理工作由内核完成。内核为进程级内部的每个线程维护上下文信息，调度是由内核基于线程完成的。
			这样就能将多个线程调度到多个处理器中，并且线程被阻塞内核可以调度到进程中的另一个线程上去。
		3).用户内核混合线程
			线程的创建完全在用户空间完成，调度和同步也在应用程序中进行。一个进程中的多个用户级线程将被映射到一些内核级线程上。
三、并发性、互斥和同步
	1.进程的交互
		交互方式分类：
			- 进程相互不知道对方的存在。交互主要存在于对于同一个磁盘、文件的访问。主要是竞争关系。
			- 进程间接知道对方的存在。不知道对方的进程ID，但是知道有进程需要交互。通过共享来进行合作。
			- 进程直接知道对方的存在。通过进程通信来进行合作。
	2.信号量
		信号量的操作：
			- 一个信号量可以初始化成非负数。
			- semWait操作使信号量减1。若减一后值为负数则进程被阻塞，否则进程继续执行。
			- semSignal操作使信号量加1。若加一后值小于或等于0，则被semWait操作阻塞的进程被解除。
		二元信号量初始化为1，取值只可能是0或1。二元信号量又叫互斥量。
		semSignal会导致多个阻塞的进程其中一个被释放，若是按semWait的执行顺序释放则被称为强信号量(FIFO队列)，否则被称为弱信号量。
	3.管程
		管程由1个或多个过程(其实就是一堆逻辑，可以看做是函数)、一个初始化序列和局部数据构成。具备如下功能：
			管程中的局部数据结构只能由管程中的过程访问。
			一个进程要进入管程，需要调用管程的一个过程。
			任何时候，只能有一个进程在管程中，调用管程的过程的其他线程将被阻塞以等待管程可用。
		管程可以提供一种互斥机制：管程中的数据变量每次只能被一个进程访问到。因此可以把共享数据结构放到管程中。管程有点类似Synchronized代码块。
		管程提供条件变量以提供对同步的支持：
			cwait(c)，调用进程的执行将在条件c上阻塞，管程可以被另一个进程使用。
			csignal(c)，恢复一个执行cwait之后因为c条件而阻塞的进程。这些恢复的进程会重新被阻塞(因为当前进程还没有出管程)。
			cnotify(c)，恢复所有执行cwait之后因为c条件而阻塞的进程。这些恢复的进程会重新被阻塞(因为当前进程还没有出管程)。
	4.消息传递
	5.读写问题
	6.进程间通信(IPC)
四、死锁和饥饿
	死锁是一组相互竞争系统资源或进行通信的进程间的永久阻塞。
	1.死锁的条件
		1).互斥，必要条件。一次只有一个进程使用资源。
		2).占用且等待，必要条件。当一个进程等待其他进程资源时，资源不释放。
		3).不可抢夺，必要条件。不能强行抢占已经被占用的资源。
		4).循环等待，必要条件。存在一个封闭的进程练，使得每个进程至少占有此链中下一个进程所需的一个资源。
		其实，上述4个条件组成了死锁的重要条件。
	2.死锁的预防
		采用某种策略，绕开出现死锁的条件。
		1).互斥：
		2).占有且等待
			一个进程可以一次性的请求完所有需要的资源，并且阻塞这个进程直到所有请求都同时满足。这样就能避免进程执行中去等待资源。
			虽然可以预防死锁，但是效率相当低下：
				- 进程很可能阻塞很长时间以满足所有资源请求。
				- 分配给一个进程的资源可能相当长的时间不会被使用。这样会让别的需求该资源的进程阻塞很长时间。
				- 一个进程开始的时候往往不知道自己所需要的所有资源。
		3).不可抢占
		4).循环等待
			如果一个进程以及分配到了R的资源，那么接下来请求的资源只能是那些排在R之后的资源。
			给每种资源预先指定一个下标，当i<j时资源Ri排在资源Rj的后面。进程申请到了Rj资源，那么该进程是不能申请Ri资源的。
			当某个进程有Rj时，就意味着有的含Ri进程可能申请Rj，为了避免含Rj的进程申请Ri，因此含Rj的进程是不能申请排在后面的资源的。
			比如进程1有R1，进程2有R2，进程3有R3。进程1可以申请R2，进程2可以申请R3，进程3可以申请R4，但是不能申请R1或者R2。
		5).乐观锁
			乐观锁可以把上面的条件全部打破。给一个资源上乐观锁，其实就是读取该资源。
			需要一个资源的时候，读取即可，完全不会阻塞当前线程。并且后面上锁的如果执行的快可以率先进行赋值，这样就相当于抢占。并且也不会循环等待。
	3.死锁的避免
		允许死锁的条件存在，但是通过明智的选择确保永远不会到达死锁点。
		在死锁避免中，是否运行进程的资源分配请求是通过是否会导致死锁来判断的。因此死锁避免需要知道将来的进程资源请求情况。	
		1).n个进程和m个资源的系统中，存在如下定义。
			- Resource  = R = Ri(i=1,...,m),  			Ri是资源i的总量。
			- Available = V = Vi(i=1,...,m),  			Vi是资源i的剩余量。
			- Claim     = C = Cij(i=1,...,n;j=1,...,m)	Cij是进程i对资源j的需求
			- Allocation= A = Aij(i=1,...,n;j=1,...,m)	Aij是进程i已经拿到的资源j的数量
		2).最简单的死锁避免策略
			如果一个新进程的需求会导致死锁，则拒绝启动这个新进程Pn+1。仅当
				Rj>=C[n+1][j]+sum(i, C)     <-    即将新开的n+1进程对于每个资源的请求都不会导致超过该资源的最大值时，才允许n+1进程开启，否则拒绝。
			这种策略不是最优的，因为会假设每个在运行的进程始终保持最大的资源使用。
		2).资源分配拒绝策略
			又称银行家算法。
			当有进程对资源做出请求的时候，先判断请求成功后是否为安全状态，若为安全状态则同意该资源请求，否则拒绝。
			这个和简单死锁避免策略的根本不同点在于粒度是请求，而简单死锁避免策略的粒度是进程。
			安全状态：
				当处于安全状态时，那么剩余的资源可以为至少一个进程完全提供，以保证该进程完成。
				当剩余的资源不足以让任何一个进程完全退出时，那么不是安全状态。
				C-A是当前每个进程对各个资源的需求情况，对于某个进程而言，V(资源剩余量)的各个资源都大于等于该进程对于各个资源的需求情况，这样就是安全状态。
			就算处于非安全状态，也不一定死锁，但是有可能死锁。当处于安全状态时，是一定不会死锁的。
	4.死锁的检测
		死锁预防策略是非常保所的，通过限制访问资源和在进程上强加约束来解决死锁问题。
		死锁检测不限制资源访问或约束进程的行为，只要有可能，被请求的资源就分配给进程。