一、概述
	1.简化java开发
		1).POJO
			spring使用组件是非侵入性的，不用继承任何类。
		2).依赖注入
			为了降低组件和组件之间的依赖，避免一个组件中指定一个具体的实现类（因为若指定了具体实现类，那么依赖性很强）采用依赖注入。
			依赖注入可以通过组件的构造函数和setter-getter方法实现。
		3).应用切面
			AOP，面向切面编程。系统有许多不同组件构成，组件只需要关注自己需要关心的就好，不应该承担其他任务。
			与组件核心功能无关的职责，主要是日志、事务管理、安全检查等等，这些系统服务通常称为横切关注点。若没有aop编程：
				a).实现系统关注点功能的代码将会重复出现在多个组件中。
				b).组件会因为那些与自身核心业务无关的关注点代码而混乱。
		4).消除样板代码
			例如jdbc中和核心业务相关的异常处理、打开数据库连接等等。这些在spring都采用模板编程来消除了。
	2.bean与容器
		在Spring应用中，组件对象必须由Spring容器它才具备多种功能，例如di和aop。
		默认情况下，在xml配置文件中一个<bean />就是一个对象。
		1).spring容器
			spring容器有多种，但可以归为两种：
				i).bean工厂
					由org.springframework.beans.factory.beanFactory接口定义，是最简单的容器。提供基本的DI支持。
				ii).上下文
					由org.springframework.context.ApplicationContext接口定义，并且是基于BeanFactory构建的。提供了框架级别的服务。
					bean工厂太过底层，因此大多数情况都是使用的上下文容器。以下几种上下文是最常用的。
					a).AnnotationConfigApplicationContext
						从一个或多个基于Java的配置类中加载spring应用上下文。
					b).AnnotationConfigWebApplicationContext
						从一个或多个基于java的配置类中加载spring web应用上下文。
					c).ClassPathXmlApplicationContext
						从【类路径】下的一个或多个xml配置文件中加载上下文定义
					d).XmlWebApplicationContext
						从Web应用下的一个或多个xml配置文件中加载上下文定义。
					e).FileSystemXmlApplicationContext
						从【文件系统】下的一个或多个xml配置文件中加载上下文定义。
					使用ApplicationContext context = new ClassPathXmlApplicationContext("xxx.xml");就可以将该xml中的上下文加载到spring中。
		2).bean的声明周期
			加载xml文件，便开始构建bean对象:
			a).spring对bean进行实例化。
			b).spring将值和bean的引用注入到bean对应的属性中。
			c).若bean实现了BeanNameAware接口，spring将bean的id传递给setBeanName()方法。
			d).若bean实现了BeanFactoryAware接口，spring将bean的BeanFactory实例传递给setBeanFactory()方法。
			e).若bean实现了ApplicationContextAware接口，spring将bean的上下文引用传递给setApplicationContext()方法。
			f).若bean实现了BeanPostProcessor接口，spring将调用postProcessBeforeInitialization()方法。
			g).若bean实现了InitializingBean接口，spring它的afterPropertiesSet()方法。当然，若使用init-method声明了初始化方法，声明的该方法也会被调用。
			h).若bean实现了BeanPostProcessor接口，spring将调用postProcessAfterInitialization()方法。
			i).此时bean已经就绪，可以被引用程序使用了，并且一直驻留在应用上下文中。
			j).上下文被销毁。
			k).若bean实现了DisposableBean接口，spring将调用destory()接口方法。若使用destroy-method声明了销毁方法，该方法也会被调用。

二、装配bean
	1.在xml中进行显示的配置
		1).配置规范
			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				xmlns:context="http://www.springframework.org/schema/context"
				xmlns:mvc="http://www.springframework.org/schema/mvc"
				xsi:schemaLocation="
				http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd
				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
				http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd">
			
			</beans>
			在<beans>中可以配置多个<bean>
		2).bean配置
			<bean class="<class-name>" />
			在没有给出id的时候，会根据全限定类名来进行生成id = <class-name>#0, 最后1个数字是索引，标记这是第几个该类的对象。
			为了方便引用该bean，通常会给bean一个id:<bean id="<id>" class="class-name" />
			a).构造器注入
				通过构造器注入，是spring实例化该bean时，将需要注入的引用和值通过构造器注入到bean中。
				i).<constructor-arg>
					<bean>
						<constructor-arg ref="<>" />
						<constructor-arg value="<>" />
					</bean>
					可以配置多个<constructor-arg />这个标签是有顺序的，顺序应该和构造器参数顺序一致。个别情况spring可以判断顺序，但是尽量就和构造器参数顺序一致。
				ii).c-命名空间
					这个方式需要修改xml头部，这里暂不叙述。
			b).属性注入
				可以通过setter方法进行注入(只有setter即可)
				i).<property>
					<bean>
						<property name="<property-name-in-class>" ref="<id-in-spring>" />
						<property name="<property-name-in-class>" value="<new-value>" />
					</bean>
				ii).p-命名空间
			c).可以注入的标签和属性（这里称为注入标签）
				i).ref/<ref>
					这个是设置当前bean某个属性引用，这个引用的对象应该也是有spring管理的一个bean。需要指明引用对象的id。可用标签，也可以用标签上的属性。
				ii).value/<value>
					这个是设置当前bean某个属性的值，支持String int boolean，可以自动将String转换为对应属性的值。可用标签，也可以用标签上的属性。
				iii).<bean>
					这个可以直接定义一个对象。
				iv).<list>
					List对象可以使用的标签，这个标签里面可以签其他注入标签。
				v).<set>
					Set对象可以使用的标签。
				vi).<map>
					Map对象可以使用的标签。
	2.在java中进行显示的配置
		和xml配置相同，需要添加一个配置文件，在配置文件中添加bean。但不同于xml语法，这里使用java语法来进行配置。
		1).添加配置文件
			配置文件是一个类.类名什么的随意。
			import org.springframework.context.annotation.Configuration;

			@Configuration
			public class CDPlayerConfig {

			}
			@Configuration这个注解说明这是个spring配置类。
		2).声明bean
			bean是配置在配置类中的
			@Bean
			public <class-name> <method-name/id>(){
				return new <class-name>(...);
			}
			@Bean注解就是声明这是配置类。并且这个bean的id就是这个方法名。
			也可以通过@Bean(name="<id>")来设置一个id。这些个方法里面都可以添加逻辑代码。
		3).注入
			a).构造函数注入
				@Bean
				public <class-name> <method-name/id>(){
					return new <class-name>(<method-name-in-javaconfig>());
				}
				虽然可以看到每个<method-name-in-javaconfig>()方法中都是返回一个new的对象，因此会认为这里注入的引用会是新对象。其实不是的。
				对于有@Bean注解的方法，spring会拦截对它的调用，并直接返回该方法之前创建过的对象。因为这是个单例模式的。
			b).setter注入
				其实也和构造函数注入差不多。只是在该方法中获得这个对象，然后用对象的setter方法来设置。
			c).本质
				加载java配置文件时，会扫描每个@Bean，并且每个@Bean方法都会返回一个新对象，这个对象会缓存在spring中，并且这个对象就是spring管理的bean。
				其注入方式就和普通的java代码几乎一模一样。只有一点不同，直接使用@Bean的方法来获得对象时，获得是单例模式的对象。
	3.隐式的bean发现机制和自动装配
		自动化装配依赖于两个技术:组件扫描和自动装配。
		1).创建可被扫描的bean
			带有@Component注解的实现类，都是可以被扫描的。被扫描的意思是会创建一个该类的对象并由spring管理。
			并且需要了解的是，若没有显示指定@Component的id，那么id就是首写字母小写的类名。
			可以通过@Component("<id>");来指定该component的id。
		2).启用扫描
			为了启用扫描，还是得需要一个启动扫描的配置文件，xml和javaconfig都可以实现。
			a).xml
				<context:component-scan base-package="<package-name>" />
				将扫描指定包中的所有类，被@Component的类将被添加到spring中。
			b).javaconfig
				@Configuration
				@ComponentScan
				public class <config-class-name>{}
				这里的配置类可以为空，因为是扫描的方式来添加的bean。这个扫描的位置默认是当前这个配置类所在的包中。
				可以通过@ComponentScan(basePackages="<package-name>");来指定搜索的包
				@ComponentScan(basePackages={"<package-name>","<package-name>"});可以指定多个包。
		3).自动装配(注入)
			对于value的属性，可以通过设置类初值的方式注入。而对于引用类型的属性，则需要使用自动装配注解来注入。
			a).构造函数注入
				在构造器的位置添加@Autowired注解
				@Autowired
				public ctor(<class-name> object){
					this.object = object;
				}
				这样扫描到当前bean时，发现构造器需要自动装配，那么就在spring容器中寻找到一个与<class-name>相同的bean来注入。
			b).setter方法注入
				@Autowired
				public setter(<class-name> object){
					this.object = object;
				}
			c).属性注入
				@Autowired
				private <class-name> object;
				就算这样也可以注入进去
				
				这样扫描到当前bean且在bean实例化后，就在spring容器中寻找到一个与<class-name>相同的bean来注入。
			需要注意的是，@Autowired是利用<class-name>来选择bean的，若有两个不同的bean但具有相同的类，或者是相同的父类，那么这时是会发生冲突异常的，因为spring不知道选择哪个注入。
			若没有在spring容器中找到对应<class-name>的bean，也会抛出异常。使用@Autowired(required=false)，当没找到对应的bean时不会抛出异常，而是注入null。
			
		4).消除自动装配歧义
			因为默认Bean的id是类名，类名是基本不会重的。但是在自动装配是可以使用父类的，这样的话所有子类都会冲突，这样就需要消除歧义。
			消除歧义主要是通过限定符注解@Qualifier("...")
			@Autowired
			@Qualifier("<限定符/id>")
			public ctor(<class-name> object){...}
			需要注意的是，每个bean都有自己的限定符，并且限定符不等同于id，只是默认情况下一个bean的限定符和id是相同的。
	4.bean的作用域
		1).作用域类型
			a).Singleton
				单例，在整个应用中只创建bean的一个实例。默认的。			
			b).Prototype
				原型，每次注入或者通过ApplicationContext获取的时候，都会创建一个新的bean。
			c).Session
				在web应用中，为每个会话创建一个bean实例。在单个session中时，申请的bean是单例的。
			d).Request
				在web应用中，为每个请求创建一个bean实例。在单个请求中时，申请的bean是单例的。
		2).作用域配置
			a).自动扫描
				@Component
				@Scope("<scope-type>")
				class <class-name>{
					...
				}
			b).JavaConfig
				@Configuration
				class JavaConfig{
					@Bean
					@Scope("<scope-type>")
					public <class-name> <method-name/id>(){
						return new <class-name>();
					}
				}
			c).xml
				<bean id="" class="" scope="<scope-type>">
三、AOP
	面向切面编程。