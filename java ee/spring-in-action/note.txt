一、概述
	1.简化java开发
		1).POJO
			spring使用组件是非侵入性的，不用继承任何类。
		2).依赖注入
			为了降低组件和组件之间的依赖，避免一个组件中指定一个具体的实现类（因为若指定了具体实现类，那么依赖性很强）采用依赖注入。
			依赖注入可以通过组件的构造函数和setter-getter方法实现。
		3).应用切面
			AOP，面向切面编程。系统有许多不同组件构成，组件只需要关注自己需要关心的就好，不应该承担其他任务。
			与组件核心功能无关的职责，主要是日志、事务管理、安全检查等等，这些系统服务通常称为横切关注点。若没有aop编程：
				a).实现系统关注点功能的代码将会重复出现在多个组件中。
				b).组件会因为那些与自身核心业务无关的关注点代码而混乱。
		4).消除样板代码
			例如jdbc中和核心业务相关的异常处理、打开数据库连接等等。这些在spring都采用模板编程来消除了。
	2.bean与容器
		在Spring应用中，组件对象必须由Spring容器它才具备多种功能，例如di和aop。
		默认情况下，在xml配置文件中一个<bean />就是一个对象。
		1).spring容器
			spring容器有多种，但可以归为两种：
				i).bean工厂
					由org.springframework.beans.factory.beanFactory接口定义，是最简单的容器。提供基本的DI支持。
				ii).上下文
					由org.springframework.context.ApplicationContext接口定义，并且是基于BeanFactory构建的。提供了框架级别的服务。
					bean工厂太过底层，因此大多数情况都是使用的上下文容器。以下几种上下文是最常用的。
					a).AnnotationConfigApplicationContext
						从一个或多个基于Java的配置类中加载spring应用上下文。
					b).AnnotationConfigWebApplicationContext
						从一个或多个基于java的配置类中加载spring web应用上下文。
					c).ClassPathXmlApplicationContext
						从【类路径】下的一个或多个xml配置文件中加载上下文定义
					d).XmlWebApplicationContext
						从Web应用下的一个或多个xml配置文件中加载上下文定义。
					e).FileSystemXmlApplicationContext
						从【文件系统】下的一个或多个xml配置文件中加载上下文定义。
					使用ApplicationContext context = new ClassPathXmlApplicationContext("xxx.xml");就可以将该xml中的上下文加载到spring中。
		2).bean的声明周期
			加载xml文件，便开始构建bean对象:
			a).spring对bean进行实例化。
			b).spring将值和bean的引用注入到bean对应的属性中。
			c).若bean实现了BeanNameAware接口，spring将bean的id传递给setBeanName()方法。
			d).若bean实现了BeanFactoryAware接口，spring将bean的BeanFactory实例传递给setBeanFactory()方法。
			e).若bean实现了ApplicationContextAware接口，spring将bean的上下文引用传递给setApplicationContext()方法。
			f).若bean实现了BeanPostProcessor接口，spring将调用postProcessBeforeInitialization()方法。
			g).若bean实现了InitializingBean接口，spring它的afterPropertiesSet()方法。当然，若使用init-method声明了初始化方法，声明的该方法也会被调用。
			h).若bean实现了BeanPostProcessor接口，spring将调用postProcessAfterInitialization()方法。
			i).此时bean已经就绪，可以被引用程序使用了，并且一直驻留在应用上下文中。
			j).上下文被销毁。
			k).若bean实现了DisposableBean接口，spring将调用destory()接口方法。若使用destroy-method声明了销毁方法，该方法也会被调用。

二、装配bean
	1.在xml中进行显示的配置
		1).配置规范
			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
					 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					 xmlns:aop="http://www.springframework.org/schema/aop"
					 xmlns:tx="http://www.springframework.org/schema/tx"
					 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
					   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
					   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd"
					   default-autowire="byName">
			</beans>
			在<beans>中可以配置多个<bean>
		2).bean配置
			<bean class="<class-name>" />
			在没有给出id的时候，会根据全限定类名来进行生成id = <class-name>#0, 最后1个数字是索引，标记这是第几个该类的对象。
			为了方便引用该bean，通常会给bean一个id:<bean id="<id>" class="class-name" />
			a).构造器注入
				通过构造器注入，是spring实例化该bean时，将需要注入的引用和值通过构造器注入到bean中。
				i).<constructor-arg>
					<bean>
						<constructor-arg ref="<>" />
						<constructor-arg value="<>" />
					</bean>
					可以配置多个<constructor-arg />这个标签是有顺序的，顺序应该和构造器参数顺序一致。个别情况spring可以判断顺序，但是尽量就和构造器参数顺序一致。
				ii).c-命名空间
					这个方式需要修改xml头部，这里暂不叙述。
			b).属性注入
				可以通过setter方法进行注入(只有setter即可)
				i).<property>
					<bean>
						<property name="<property-name-in-class>" ref="<id-in-spring>" />
						<property name="<property-name-in-class>" value="<new-value>" />
					</bean>
				ii).p-命名空间
			c).可以注入的标签和属性（这里称为注入标签）
				i).ref/<ref>
					这个是设置当前bean某个属性引用，这个引用的对象应该也是有spring管理的一个bean。需要指明引用对象的id。可用标签，也可以用标签上的属性。
				ii).value/<value>
					这个是设置当前bean某个属性的值，支持String int boolean，可以自动将String转换为对应属性的值。可用标签，也可以用标签上的属性。
				iii).<bean>
					这个可以直接定义一个对象。
				iv).<list>
					List对象可以使用的标签，这个标签里面可以签其他注入标签。
				v).<set>
					Set对象可以使用的标签。
				vi).<map>
					Map对象可以使用的标签。
	2.在java中进行显示的配置
		和xml配置相同，需要添加一个配置文件，在配置文件中添加bean。但不同于xml语法，这里使用java语法来进行配置。
		1).添加配置文件
			配置文件是一个类.类名什么的随意。
			import org.springframework.context.annotation.Configuration;

			@Configuration
			public class CDPlayerConfig {

			}
			@Configuration这个注解说明这是个spring配置类。
		2).声明bean
			bean是配置在配置类中的
			@Bean
			public <class-name> <method-name/id>(){
				return new <class-name>(...);
			}
			@Bean注解就是声明这是配置类。并且这个bean的id就是这个方法名。
			也可以通过@Bean(name="<id>")来设置一个id。这些个方法里面都可以添加逻辑代码。
		3).注入
			a).构造函数注入
				@Bean
				public <class-name> <method-name/id>(){
					return new <class-name>(<method-name-in-javaconfig>());
				}
				虽然可以看到每个<method-name-in-javaconfig>()方法中都是返回一个new的对象，因此会认为这里注入的引用会是新对象。其实不是的。
				对于有@Bean注解的方法，spring会拦截对它的调用，并直接返回该方法之前创建过的对象。因为这是个单例模式的。
			b).setter注入
				其实也和构造函数注入差不多。只是在该方法中获得这个对象，然后用对象的setter方法来设置。
			c).本质
				加载java配置文件时，会扫描每个@Bean，并且每个@Bean方法都会返回一个新对象，这个对象会缓存在spring中，并且这个对象就是spring管理的bean。
				其注入方式就和普通的java代码几乎一模一样。只有一点不同，直接使用@Bean的方法来获得对象时，获得是单例模式的对象。
	3.隐式的bean发现机制和自动装配