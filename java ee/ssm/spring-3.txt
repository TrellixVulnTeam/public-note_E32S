一 Spring IOC
    1. tiny spring架构
        1).ApplicationContext
            ApplcationContext中有一个BeanFactory
            加载loadBeanDefinitions时，会构造一个Reader实例，通过调用Reader的loadBeanDefinitions来读取Xml文件中的bean配置到BeanDefinition中，这些BeanDefinition保存在Reader中。
            取出Reader中的BeanDefinition，中BeanFactory中注册。
        2).Reader
            Reader类中有一个ResourceLoader和一个Map，Loader用来将指定路径的Resource得到，Map用来缓存加载的BeanDefinition
        3).ResourceLoader
            ResourceLoader用于获得路径处的Resource。
        4).Resource
            有多种Resource，有的基于Classpath，有的基于FileSystem，通过Resource类，将不同资源获取inputstream的接口统一。
    2.spring架构
        1.ApplicationContext
            ApplicationContext中有一个BeanFactory，且是ResouceLoader的一个子类
            在refresh时，都会把之前用的BeanFactory销毁掉，创建一个新BeanFactory。还是会创建一个XmlBeanDefinitionReader，用来读取Xml文件的BeanDefinition并缓存起来。
            ApplicationContext的loadBeanDefinition方法，实际上就是创建Reader，然后拿到自己实现的Resource，再将Resource和beanFactory交给Reader进行loadBeanDefinition。
        2.Reader
            Reader，这里面有ResourceLoader，BeanFactory等对象，Reader执行loadBeanDefinitions后，将会把指定location中的bean生成BeanDefinition并交给beanFactory。
            需要强调的是，ResourceLoader就是ApplicationContext实例本身，因为这个实例是ResourceLoader的子类，并且实现了自己需要的Resource获取。
        3.Resource
        4.DefaultListableBeanFactory
            这个类中有个HashMap保存了所有的BeanDefinition，Reader读取解析出BeanDefinition后，应该就交给它了。更正确的说，在Reader得到一个BeanDefinition后，将会使用beanFactory的registerBeanDefinition(beanName, beanDefinition)来注册beanDefinition。这样Reader解析完所有的BeanDefinition，并向beanFactory中注册beanDefinition，就完成了IoC容器的初始化过程，是后面依赖注入的基础。
    3.IoC依赖注入
        发生依赖注入的过程，是用户第一次向IoC容器所要Bean时触发，即用到哪个对象再实例化哪个对象，当然它所依赖的对象也会实例化。也可以用lazy-init属性来让容器完成Bean的预实例化，即在容器初始化完成时就进行实例化。
二 Spring MVC
    1.ContextLoaderListener
        这个是在web.xml中配置的监听器，在加载springmvc的bean之前，会先通过该监听器加载一些用户定义的bean。在这里面形容的容器，被称为【根上下文】
        在ContextLoaderListener的contextInitialized方法中进行bean加载：initWebApplicationContext(event.getServletContext());加载的方式是初始化一个XmlWebApplicationContext的IoC来作为bean的容器。
        1).XmlWebApplicationContext
            该容器类中有DEFAULT_CONFIG_LOCATION="/WEB-INF/applicationContext.xml"来指定默认的配置文件名。
            里面通过初始化Reader，指定beanFactory来进行beanDefinition的注册于加载。
            当容器建好了，容器最终存放的地方是servletContext。通过getAttribute()来获得。其key在WebApplicationContext的一个常量来指定，这是XmlWebApplication的基类。
        2).WebApplicationContext
            XmlWebApplicationContext的父类，主要指定了一些常量，例如常用的ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE。
            当需要获取这个容器时(因为用户定义的bean都放在了这里面，因此常用)，需要通过
            servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE)来取得该容器。或是通过
            WebApplicationContextUtils.getWebApplicationContext(servletContext); 来获得
    2.DispatcherServlet
        在完成了ContextLoaderListener的操作后，web容器开始初始化DispatcherServlet。
        DispatcherServlet会加载springmvc配置需要的bean，加载到一个新的容器中，该容器的双亲是在ContextLoaderListener中加载的那个(根上下文)。这个新容器也会保存在ServletContext中。
        由于web上下文的双亲是根上下文，而从一个上下文中getBean，是先到双亲中去找，没找到才到当前容器中去找，因为这个机制，实现了在根上下文中的bean共享。
        继承结构:HttpServlet <---- HttpServletBean <---- FrameworkServlet <---- DispatcherServlet
        1).DispatcherServlet的启动和初始化
            a).HttpServletBean
                初始化是在HttpServletBean类中开始的。在这里面会获取一些初始化参数，并通过调用initServletBean()，将更复杂的初始化交给子类FrameworkServlet来完成。
            b).FrameworkServlet
                在这里面会初始化容器上下文this.webApplicationContext = initWebApplicationContext();
                在initWebApplicationContext方法中，将获取根上下文，并将其作为parent来创建web上下文。新的上下文将会放到servletContext中。这样新的上下文环境就建立起来了。
                上下文环境建立起来了，还需要根据环境的内容配置handlerMapper 拦截器 等等结构方便对请求进行dispatch。通过initWebApplicationContext方法中执行【onRefresh方法】来跳到子类DispatcherServlet中进行初始化。
            c).DispatcherServlet
                父类中的onRefresh方法，会到当前类中，实际调用的是initStrategies来进行更进一步的初始化，这里面对多个mvc部件初始化。
                protected void initStrategies(ApplicationContext context) {
                    ...
                    initHandlerMappings(context);               //为http请求找到想要的controller，在其中将会获取所有的mappings
                    initHandlerAdapters(context);               //不同的adapter的调用以及输入输出封装不同，比如类型检查，json转换
                    ....
                    initViewResolvers(context);
                    ...
                }