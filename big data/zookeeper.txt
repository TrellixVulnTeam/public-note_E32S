一 简介
    1.特点：
        1).简单，核心是一个文件系统。
        2).具备组织力，可以用于实现多种协调数据结构和协议。如分布式队列，分布式锁和一组节点的领导者选举。
        3).高可用，zookeeper的集群是高可用的，避免单点故障导致系统崩溃。
        4).松耦合，zookeeper的客户端进程之间可以不用相互了解，通过在zookeeper中留消息的方式来进行交互。
        5).资源库，提供一个通用协调模式实现方法的开源库。
    2.使用场景
        有一组服务器用于为客户提供某种服务，客户端只需要找到集群中的其中一个节点就可以使用这项服务，又因为服务是分布在多个节点上的，因此需要让服务器集群中的节点知道集群中的所有的节点，这就需要维护一个节点列表。
        需要解决的问题:
            1).存储问题。节点列表不应该放在单个节点上，因为当单个节点宕机服务就不能提供了。
            2).剔除问题。如何当其中一个节点宕机，从节点列表中剔除它。
        可以利用zookeeper的短暂znode机制解决这类问题。服务器集群中有两部分 zookeeper集群和实际提供服务的集群，提供服务的集群是zookeeper的客户端。
        这里需要明确的是，zookeeper的客户端组通常就是实际提供服务的集群。
    3.zookeeper存储结构
        是一个类似于文件系统的树结构，使用的是节点作为存储单位的。节点中可以有多个子节点，节点可以是单纯的数据。在下面有更具体的介绍。
二 zookeeper服务
    1.数据模型
        zookeeper维护着一个树形层次结构，树中的节点被成为znode。znode可以用于存储数据，并且有一个与之关联的ACL(访问权限)。
        zookeeper用于实现协调服务，而不是大数据存储。因此每个znode可以保存的数据被限制在1MB以内。
        zookeeper的操作具备原子性，客户端的相关操作，要么执行成功，要么执行失败。
        zookeeper中的节点通过路径被引用，引用方式类似linux中的文件系统。
        1).短暂znode
            znode有两种类型：短暂的和持久的。znode的类型在创建时会确认。
            短暂znode依赖于客户端会话，当会话失效时短暂znode将会被删除。而持久znode不会因为会话失效而被删除。
            采用短暂znode可以让节点群能够及时知道现在哪些进程是活跃的。因为会话由进程创建，当进程被kill掉时会话也就失效了。
        2).顺序号
            可以给znode设置顺序标识，顺序标识是一个递增计数器，可以很简单的标识一些全局顺序。
        3).观察
            zookeeper实现了观察者模式，znode是被观察的。当znode发生了某些事件，可以触发观察者的回调。观察者的回调由客户端代码实现。
            需要注意的是，观察只能被触发【一次】，若需要多次收到通知则需要重新注册观察者。
    2.操作
        zookeeper提供了九种基本操作:
            a).create, 创建一个znode。
            b).delete, 删除一个znode(该znode不能有子节点)。
            c).exists, 测试一个znode是否存在并且查询其元数据。
            d).getACL, setACL, 获取/设置要给节点的ACL。
            e).getChildren, 获取一个znode的子节点列表。
            f).getData, setData, 获取/保存一个znode所保存的数据。
            g).sync, 将客户端连接的集群节点的znode视图与zookeeper同步。(因为zookeeper的集群节点的数据有可能不一致)
        1).集合更新
            通过multi操作，可以将多个基本操作合成一个操作单元，要么都成功，要么都失败。将多个操作合成原子操作，这类似与事务。
        2).观察触发器
            在exists, getData, getChildren这些操作上可以设置观察，这些观察会被create，delete，setData操作触发。
            * 使用exists观察的znode，被创建，删除或数据更新时将会触发。
            * 使用getData观察的znode，被删除或数据更新时将会触发。
            * 使用getChilder观察的znode，子节点被创建和删除时将会触发。
        3).ACL列表
            每个znode被创建时都会带一个ACL列表，用于决定谁可以对它执行何种操作。
    3.实现
        zookeeper有两种运行模式：独立模式和复制模式。独立模式就是只有一个zookeeper服务器，通常用于测试环境。复制模式是使用zookeeper集群。
        zookeeper集群必须保证集群中有超过一半的机器正常工作，这样zookeeper的机制才能保证系统是高可用的。
        1).领导者选举
            集群中的所有节点通过一个选择过程来选择出一台leader节点，其他的节点被称为follower。
        2).原子广播
            所有的写请求都会转发给leader，再由leader将请求广播道follower，当半数以上的follower执行该请求并持久化后，leader才会记录该次更新，并返回客户端一个成功的响应。
        3).领导者重选
            当leader宕机，其余节点会选出一个新的leader，并继续提供服务。前leader恢复后，将改变身份成为新leader的follower。
            选举过程大概200ms左右。
        所有的zookeeper的节点都保存了整个zookeeper的数据，由leader来广播修改让节点修改数据。当zookeeper节点收到读请求，则会直接从自己读取数据将来返回给客户端。
    4.一致性
        一个follower可能滞后于leader的几次更新(因为leader并不保证每次要求所有follower都更新，只需要半数以上的更新请求就生效)。
        当follower和leader的更新记录完全相同时，就认为follower和leader同步。也因此客户端不会都连接到和leader完全同步的follower。
        由于客户端的每次都是从链接的节点取数据，因此此时去到的数据很可能并不是leader的最新的操作结果。
        每个对znode树的更新操作，都会被赋予要给全局唯一的id，称为zxid，该id是按操作的顺序来排号的。时间上后发生的操作，id值更大。zookeeper可以保证以下的一致性：
            1).顺序的一致性
                来自任意客户端的更新都会按其发送顺序被提交。因此在其他客户端将会按顺序看到对应的修改。  
            2).原子性
                每个更新操作，要么成功，要么失败。
            3).单一系统映像
                一个客户端连接到任意的服务器，看到的都是相同的系统视图。意味着客户端在同一个会话中，连接到一个新的服务器，该服务器的系统状态不会比之前的服务器系统状态更老。
            4).持久性
                一个更新一旦成功，其结果就会持久存在无法撤销。
            5).及时性
                任何客户端看到的滞后系统都是有限的。
        由于不同的客户端链接到zookeeper后由于节点滞后的原因，得到的视图可能是不同的，这时如果需要强制相同，客户端需要执行sync操作。该操作将连接的节点与leader同步，用以保证数据是最新的。
    5.会话
        客户端配置了zookeeper集群的节点列表，在启动的时候会去连接列表中的节点，直到其中一个节点连接上。当连接的节点宕机后也会自动去连接其他节点。
        一旦建立了连接，就创建了一个新的【会话】，每个会话都有一个超时时间，这个时间在创建的时候设定。若会话在指定的时间内没有收到任何请求，则相应的会话过期。
        过期的会话无法再使用，若客户端向继续和zookeeper集群交互需要创建新的会话。服务器当判断到会话失效，那么就会清除会话用到的短暂znode。
        客户端的代码库中自带了维护会话的机制(间歇性发送ping请求)，因此不需要程序员维护会话。
        zookeeper节点故障导致的重新连接将不会使会话失效。
    6.zookeeper对象状态
        对象在生命周期中会经历不同的状态，可以通过getStat方法来查询对象状态。

3.zookeeper构建应用
    1).配置服务
    2).可复原的zookeeper应用
    3).锁服务
        分布式锁可以为一组进程提供锁服务，使的任意时刻只有一个进程持有锁。分布式锁可以用于在大型分布式系统中实现【领导者选举】。
        使用顺序znode为竞争锁的进程强制排序，每次序号最小的znode对应的进程持有锁，也就是该进程是leader。当该leader宕机后，将会释放锁，由下一个节点的进程得到锁成为leader。
        客户端需要捕捉这个znode的变化，以更新当前获得当前最新的leader。
基本程序
    1).创建节点
    2).添加节点
    3).显示节点成员
    4).删除节点