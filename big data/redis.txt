一 简介
    开源免费，遵循BSD协议.是一种面向"key/value"的【内存】数据库。
    1.特点:
        1).数据持久化，重启的时候可以再次加载并进行使用。
        2).支持主从结构(master-slave, 负载均衡， 高可用)。
        3).支持持久化。
        4).集群。
    2.优势:
        1).性能高，读速度是11W次/s，写速度是8.1w次/s。
        2).丰富的数据类型支持。
        3).原子性，所有操作都是院子的。
        4).其他特性，支持publish/subscribe, 通知, key过期等。
    3.安装和使用
        1).安装
        2).服务端
            默认有16个数据库 0~15，数据库数量在再配置文件中有配置。数据库名称只能说数字，不能是字符串。
        3).客户端
            redis-cli -h <server-ip> -p <port> 连接到服务器，并进入redis控制台。默认进入0号数据库。
            redis-cli 等价于 redis-cli -h 127.0.0.1 -p 6379 写死了的。
            redis-cli shutdown 或是在redis-cli控制台下执行shutdown，关掉服务端redis进程。
            select 1，进入1号数据库。
            quit    退出redis控制台
        4).基础指令
            keys <通配符>  查询数据库中满足通配符的所有key，*代表任意字符，?代表1个任意字符，[0-9]代表1个数字
            del <key>       删除一个kv对，返回删除了几个
            exists <key>    判断是否存在这个键
            type <key>      返回key所对应的value类型
            help @<GROUP>   操作指定GROUP所涉及到的所有方法，GROUP是数据类型名称，比如string。
    4.值支持的数据类型
        1).String
            redis是kv数据库，key仅支持string。
            值支持String，由于String是二进制安全的，因此也可以用来保存字节数组。
            String buffer = new String(originData);     //解码，将模式编码模式转换为Unicode。
            byte[] recoverData = buffer.getBytes();     //编码，将Unicode的字节数据转换为默认编码模式的字节数据。
        2).Hash
            值可以是HashMap。
        3).List
            值也可以是List。
        4).Set
            值还可以是Set，不重复，无序。
        5).zset
            值也能使Zset，不重复，有序。
        6).HyperLogLog
            很少用。
    5.配置
        配置文件是安装目录下的redis.conf。
        可以通过CONFIG命令 查看 或 设置 命令项。
        1).读取配置
            CONFIG GET * 获得所配置项。
            CONFIG GET <config-key> 可以获取对应名字的配置项。
        2).编辑配置
            CONFIG SET <config-key> <config-value> 将对应名字的配置设置为<config-value>
<<<<<<< HEAD
=======
        需要知道的是，使用config指令，只能在当前的环境下生效，当redis重启后就使用默认的配置文件。
        因此如果需要永久性的设置，就需要修改到配置文件中去。
        config rewrite，可以将当前配置写到配置文件里面去。
>>>>>>> d248387dc9098d0a87ec15e5081df8767b94b805
二 指令
    以下指令和数据类型是强相关的，每个指令操作的数据类型是固定的。
    若指令对应的数据类型是不对的，那么将会报错，不过set指令比较特殊，会无视<value>，直接用新的<string-value>覆盖。
    1.String相关指令
        set <key> <string-value> 设置<key>的value为<string-value>。若<string-value>中有空格，可以用冒号来标识。
        append <key> <string-value> 在<key>的<value>后面拼接一个字符串。
        mset <key1> <string-value1> <key2> <string-value2> ...    设置多个键值对
        setnx <key> <string-value> 键存在则赋值，否则放弃
        incr <key> 递增，只要<string-value>数据可以转换为数字，那么是可以递增和递减的，非数字则失败。
        decr <key> 递减。
        incrby <key> <number>  每次递增<number>, number不能是小数。
        decrby <key> <number>  每次递减<number>, number不能是小数。
        incrbyfloat <key> <number> number可以是小数。
    2.hash
        hash中可以保存多个键值对，这里面的键值类型只能说【string】。
        hset <key> <hash-key> <hash value> 在<key>中添加一对<hash-kv>键值。
        hget <key> <hash-key> 获取<key>对象中<hash-key>的<hash-value>。
        hexists <key> <hash-key> 判断<key>中的<hash-key>是否存在。
        hdel <key> <hash-key> 删除<key>中的<hash-key>。
        hkeys <key> 获得<key>中的所有的键。
        hkeys <key> 获得<key>中所有的值。
        hlen <key> 获取<key>中有多少个字段。
    3.list
        lpush <key> <list-value1> <list-value2> ... 往<key>的左边中添加指定的元素集合。
        lpop <key> 从<key>的左边弹出元素，相当于出栈。
        rpush <key> <list-value> 往<key>的右边中添加元素。
        rpop <key> 从<key>的右边弹出元素，相当于出栈。
        lrange <key> <index1> <index2> 获取下标index1到index2的元素，index若是负数，则代表倒数第index个元素。-1就代表倒数第一个元素(最后的元素)。
        llen <key> 获得<key>列表的长度
        lrem <key> <count> <list-value> 删除左边的count个<list-value>，若count为负数，那么就是删除右边的|count|个<list-value>，若count为0，那么把列表中的<list-value>清空。
        linsert <key> <before/after> <value-in-list> <new-list-value> 在指定的值前面或者后面插入数据。
        rpoplpush <key1> <key2> 将表<key1>的末尾元素，插入到表<key2>的左边。
        ltrim <key> <index1> <index2> 将表<key>的范围内元素截取出来作为这个表的值。
    4.set
        相比list，存储内容是一样，但是set唯一的，且是无序的。
        sadd <key> <set-value>  往集合<key>中添加元素。
        smembers <key>  显示集合<key>中的所有元素，和插入顺序无关。
        srem <key> <set-value> 从集合<key>中删除元素。
        sdiff <key1> <key2> 把集合<key1>中有的元素，而<key2>中没有的元素返回。
        sinter <key1> <key2> 求两个集合的交集。
        sunion <key1> <key2> 求两个集合的并集。
        sinterstore <save-key> <key1> <key2> 将交集结果保存到<save-key>集合中。
        sunionstore <save-key> <key1> <key2> 将并集结果保存到<save-key>集合中。
        scard <key> 计算结果中的元素个数。
        srandmembers <key> <num> 随机从集合中取出指定数量的元素。num若是正数，保证返回的元素是不同的，num若是负数，返回的元素可能是相同的。
    5.zset
        zadd <key> <score> <value> 往集合中添加指定【分值】的元素，拍下是根据这个分值来排序的。
        zscore <key> <value> 得到集合中指定元素的分值。
        zrange <key> <index1> <index2>     得到集合中的元素，升序。
        zrevrange <key> <index1> <index2>  得到集合中的元素，降序。
        zrangebyscore <key> <score1> <score2> 得到集合中分值范围内的元素。
        zcard <key> 返回集合中的元素格式。
        zrem <key> <value> 删除集合中的指定元素。
        zremrangebyrank <key> <index1> <index2> 删除下标范围内的元素。
        zremrangebyscore <key> <score1> <score2> 删除分值范围内的元素。
        +inf 意味着 正无穷的分值。
        -inf 意味着 负无穷的分值。
    6.其他指令
        expire <key> <s> 设置<key>的生存时间
        pexpire <key> <ms> 毫秒级设置
        ttl <key>   返回<key>的生存时间，倒计时阶段大于-1，若为-1则<key>不作倒计时，若为-2则不长脑子
        pttl <key> 毫秒级显示
        persist <key> 取消生存时间，不作倒计时
        sort <key> 将<key>列表里面的数据 排序显示，默认升序，后加desc代表降序，后面加store <key>可以将排序结果放到新的<key>中
        sort <key> by <key通配符> by后面是<key>排序的参考键，参考的排序值是<key>中的元素放到<key通配符>对应的value
            sort list by stu:*, 安装stu:*表的数据进行拍下，stu:*是个String
            sort list by stu:*->score, 按照stu:*所有表的score进行排序，这里的stu:*表是个hash
            sort list by stu:*->score get # get stu:*->score， 排序list，并根据结果显示对应的stu:*->score的数据。如果不加get #只会显示get后面的字段，get #代表获取元素本身。
            
三 事务
    是一组命令的集合，事务是最小执行单位，要么都执行，要么都不执行，主要是想保证其原子性，相当于同步。
    multi 开启事务
    事务期间的操作，都不进行操作，需要等到提交的时候才执行。(包括get指令，是无法读取到数据的)
    exec 事务结束, 相当于提交事务，将期间的命令进行执行。
    错误处理:
        1).语法错误，致命错误，直接放弃事务内的所有操作。
        2).运行错误，不会影响事务其他命令的错误。
    watch <key> 监听关键词是否被修改，当执行完一个事物，将会取消掉key的监控状态，若被修改下一个在事物中修改该值将不会成功，再下一个事务又可以修改了。
四 发布订阅模式
    subscribe <key> 订阅一个频道(字段)，将会一直等待频道的消息。
    publish <key> <msg> 向订阅的频道发送消息，订阅该频道的客户端将会收到消息。
    订阅的时候，可以通过通配符可以订阅满足通配符的频道。
五 管道
    不用管道指令，客户端执行多条指令，需要一条一条的发送请求，并且获取回应，交互次数较多。
    使用管道指令，一次请求中包含了多条指令，将多次交互压缩成两次交互。
    Pipeline pipeline = jedis.pipelined();
    pipleline.set...;
    List<Object> syncAndReturn = pipeline.syncAndReturnAll();
    管道要求多条命令之间是彼此独立的，也因此不应该认为管道操作是原子的，这和事务不同。
六 持久化
    两种持久方式，每次重新启动都会读取持久化的数据加载到数据库里面。
    1.RDB方式(默认)
        通过快照完成。当符合一定条件，会自动将内存中的所有数据执行快照操作，保存在redis根目录下的dump.rdb。
        在启动redis时，会自动将dump.rdb读取出来恢复数据。
        快照条件:
            1).自动备份
                900s 只要有1个修改，就会备份。
                300s 有10个修改，就会备份。
                60s  有1k个修改，就会备份。
                在配置文件中修改:
                    save 900 1
                    save 300 10
                    save 60 1000
            2).手动备份
                bgsave 在后台运行备份，不会阻塞。
                save 在前台运行备份，会阻塞。
        快照机制:
            fork，拷贝副本进程，父进程继续处理客户端的命令，而子进程将内存中的所有数据写入到硬盘的临时文件中，
            临时文件写完后，才会替换dump.rdb.
    2.AOF方式
        是一种日志记录方式，服务器的redis会将所有会影响数据库内容的命令都记录下来，这样子只要在redis开启的时候，将以前的命令执行一次，就会恢复最后的数据。
        通过在配置文件中设置appendonly.aof开启。日志文件保存在redis根目录的appendonly.aof文件中。
        机制:
            默认每秒进行一次同步。即将所有的键写入到aof文件中。
            在配置文件中通过appendfsync aways 可以在每次指令时，都会将指令放到日志文件中。
            配置文件设置appendfsync no 不主动进行同步，有操作系统30s同步一次。
            在适当时机还会进行重写，会查看数据库当前时刻的kv，并进行记录set k v，以忽略之前的指令，用于减少日志文件大小。
            至于重写时机，日志文件达到64M 或者 ，也可以通过bgrewrited手工重写。
    若两种方式都开启了，会默认使用aof方式，这是因为aof可以保证数据库的【完全】恢复。
三 基本编程
=======

七 安全策略
    默认redis不使用密码，因为redis一般用在内网，比较安全。
    配置文件中的 requirepass配置指定了密码。
    在没有使用密码的时候，也可以登陆，但是指令会回报没有权限。
    auth <requirepass-value> 这样设置密码。
    可以在配置文件中设置bind 127.0.0.1 绑定到本机，这样只能使用redis-cli -h 127.0.0.1的方式来访问。
八 redis的主从复制
    redis支持多个数据库之间的数据同步，一类是主数据库master，一类是从数据库slave。
    master主要负责写操作，slave主要负责读操作，做到了读写分离，负载均衡，减轻了大量请求时候的压力，提高服务器负载能力。
    1.从数据库
        配置slaveof <master-ip> <master-port> 这样用来将本数据库配置为指定主数据库的从数据库。
        通过slaveof no one指令，可以让从数据库断开，成为1个独立的主数据库。
        slave默认只能有master，但也可以通过修改slave的配置文件来放弃这样的策略。
    2.主从机制
        a).当slave启动，回想master发送sync的同步指令。
        b).master接受到sync，master就回保存快照(rdb)，期间受到的命令缓存起来。
        c).rdb完成后，redis会把快照和缓存命令发送给slave。
        d).slave收到数据后，加载rdb，并执行缓存命令。此后slave都会周期性ping master。
        e).以后master都收到写操作，都会将写操作发送给所有slave，以同步数据。
        f).查询操作在从节点执行。
    3.
        min-slaves-to-write master至少要有这么多slave时，才能往master写数据。
        min-slaves-max-lag slave会周期性ping master，master会记录slave上次ping的时间，若离当前时间超过了该参数，就认为该slave延迟太高，就认为它不存在，当它延时不大时才会使用它。
    4.sentinel
        当master宕机时，需要让slave中的一个成为master以代替宕机的master。
        sentinel也是一种redis服务，用来监视主从结构的所有计算机的，当然避免sentinel也宕机，通常sentinel需要多台。
        sentinel发现master宕机了，就会把负载较低的slave自动升级为master。
        当master宕机，单个sentinel会给它标记为【主观下线状态】，若所有sentinel都认为它宕机了，就会把标记为【客观下线状态】。这时master才真的会被下线，并用slave替换。
        若其中一台sentinel认为slave下线了，那么就算是这个slave下线了。
        通过redis-sentinel sentinel.config来启动sentinel服务，配置文件中配置了需要监控的master。不用指明从节点，从节点可以从master查询到。
        对于这样的架构，程序中需要监听sentinel以便在master-slave切换时，可以在程序里切换，jedis提供了方便的工具。
        public void testSentinel(){
            Set<String> sentinels = new HashSet<>();
            sentinels.add("<ip>:<port>");   //设置多台sentinels的位置

            JedisPoolConfig poolConfig = new JedisPoolConfig();
            JedisSentinelPool jedisSentinelPool = new JedisSentinelPool("<master-name>", sentinels, poolConfig);
            HostAndPort currentHostMaster = jedisSentinelPool.getCurrentHostMaster();   //获得当前sentinel的master消息
            Jedis jedisres = jedisSentinelPool.getResource();                           //获得当前master对应的jedis
        }
九 redis集群
    redis集群是一个可以在多个节点之间数据共享的设施。集群可以自动切分数据到多个节点，集群中的某个节点故障时，redis还可以处理客户端请求。
    一个redis集群包含16384个哈希槽，数据保存在哈希槽里面，需要为每个主节点分配hash槽以保存数据在节点中。
    集群中的每个节点需要1个至多个复制品(相当于主从结构)，如果master下线，slave可以去顶替，以保证高可用。
    redis集群最少需要3个主节点，从节点个数没有要求 没有也可以。
    修改配置文件:
        cluster-enable yes                  使能集群
        cluster-config-file nodes.conf      集群配置文件，自动生成
        cluster-node-timeout 5000           节点超时时间
    1.建立集群
        当节点都运行起来后，通过redis-trib.rb create --replicas <number> <server-ip-1>:<port-1> <server-ip-2>:<port-2> <server-ip-3>:<port-3> ...来创建集群。number是每个主节点的从节点数。
        开启集群这会自动进行主从节点的分配。
        客户端连接任意节点都行: redis-cli -c -h <remote-ip> -p <port> 这里用【-c】表示连接集群。
        在集群中不需要额外加sentinel来管理主从节点的替换，集群会自动管理。
        cluster node指令，可以查看集群信息，包括每个节点的id。
    2.集群添加节点
        1).添加从节点
            ./redis-trib.rb add-node <ip:port1> <ip:port2> 将2号机添加到1号机所在的集群中去，此时2号机是个孤立的node，虽然在集群网络中，但是还未参与，不是master(没有分配hash槽)也不是slave。
            redis-cli -c -h <server:port> -p <port> cluster replicate <master-in-cluster-id> 将指定的集群中的node设置为集群中指定master的slave。
        2).删除从节点
            ./redis-trib.rb del-node <ip:port> <node-id> 将指定节点所在的集群中的node移除。
        3).添加主节点
            ./redis-trib.rb add-node <ip:port1> <ip:port2>
            ./redis-trib.rb reshared <ip:port> 重新对指定主机所在集群的hash槽进行一个分配，通过这个方法来向新添加进来的节点分配hash槽。在执行这个指令后，后续还会指定往哪个节点分配hash槽，以及将哪些节点的hash槽拿出来分配，可以用all来代表从所有的节点随机拿出部分来分配hash槽。
        4).删除主节点
            ./redis-trib.rb reshared <ip:port> 将要删除的master的hash槽给转出来。可以将hash槽转到的指定的节点。
十 基本编程
>>>>>>> d248387dc9098d0a87ec15e5081df8767b94b805
    1.jedis类
        public void test1(){
            Jedis jedis = new Jedis(host, port);
        }

        public void test2(){
            JedisPoolConfig poolConfig = new JedisPoolConfig();
            poolConfig.setMaxTotal(100);        //总连接数
            poolConfig.setMaxIdle(10);          //空闲连接数
            poolConfig.setMaxWaitMillis(3000);  //创建连接的超时时间
            poolConfig.setTestOnBorrow(true);   //在创建连接时会测试
            JedisPool jedisPool = new JedisPool(poolConfig, host, port);
            Jedis jedis = jedisPool.getResource();  //从连接池中获得jedis
            ...
            jedisPool.returnResourceObject(jedis);   //返回给连接池
        }
        使用连接池主要有两方面原因:
            1).虽然redis操作是原子的，但是jedis并不是线程安全的，他提供的方法是有现场安全的。虽然用不同的jedis，但jedis本质上是发送请求到服务器，服务器执行redis的操作是原子的。
            2).连接池的创建较为花时间，因为有大量的通信操作，因此最好缓存起来。
    2.事务
        public void incr(){
            jedis.watch("<key>");
            Transaction multi = jedis.multi();
            multi.set("<key>", <value>);
            List<Object> exec = multi.exec();
            if(exec==null || exec.size==0){
                incr();
<<<<<<< HEAD
            }
        }
        在当前线程(jedis)中，执行了watch后，<key>将会被监控，用于确定在下一个事务期间<key>未被修改，若被修改，那么事务将会失败。执行完一个事务后，<key>的值会取消watch。也因此需要循环执行，这里是通过递归来循环的。
        总而言之，watch监听<key>在下次事务的时间内，是否被修改了。
=======
            } 
        }
        在当前线程(jedis)中，执行了watch后，<key>将会被监控，用于确定在下一个事务期间<key>未被修改，若被修改，那么事务将会失败。执行完一个事务后，<key>的值会取消watch。也因此需要循环执行，这里是通过递归来循环的。
        总而言之，watch监听<key>在下次事务的时间内，是否被修改了。
    3.集群
        public void cluster(){
            Set<HostAndPort> nodes = new HashSet<>();       //为了寻找集群而需要用到的节点，只要设置了1个，就能找到集群了，设置多个是为了安全，只要其中有一个能找到集群，集群就能使用。
            nodes.add(new HostAndPort("<ip>", <port>));
            nodes.add(new HostAndPort("<ip>", <port>));
            nodes.add(new HostAndPort("<ip>", <port>));
            
            JedisPoolConfig poolConfig = new JedisPoolConfig();
            ....    //配置JedisPoolConfig
            JedisCluster cluster = new JedisCluster(nodes, poolConfig);
            cluster.get(...);
        }
>>>>>>> d248387dc9098d0a87ec15e5081df8767b94b805
