一、介绍
	Hibernate是持久层，用于数据持久化。其实就是对jdbc做了一层封装。
	使用Hibernate可以使我们采用对象化的操作关系型数据库。
	1.优点
		1).使开发更加对象化。
		2).易移植
		3).没有侵入性，支持透明持久化。
	2.缺点
		1).使用数据库特性的语句。
		2).对大批量数据更新存在问题。
		3).系统中存在大量的统计查询功能不太适合。
	3.目录结构
		- doc		一些api参考文档
		- eg		一些demo
		- etc		一些配置文件的例子模板
		- lib		第三方依赖包
		- src		源代码
		- test		测试程序

二、开始
	Hibernate可以用在任何java项目，因为它本来就只是用于sql的。
	1.创建User Library. 加入依赖包
		* HIBERNATe_HOME/lib/*.jar
		* HIBERNATe_HOME/hibernate3.jar
		* 加入数据库驱动(mysql的jdbc驱动)
	2.添加配置文件
		hibernate.cfg.xml放到classpath可以搜索的路径下，一般放到src路径下。
		<!DOCTYPE hibernate-configuration PUBLIC
			"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
			"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

		<hibernate-configuration>
			<session-factory>
				<property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
				<property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate_first</property>
				<property name="hibernate.connection.username">root</property>
				<property name="hibernate.connection.password">root</property>
				<property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
				<property name="hibernate.show_sql">true</property>		<!-- 方便观察生成的文件 -->
				<property name="hibernate.format_sql">true</property>
			</session-factory>
			
			<!-- 指出映射文件 -->
			<mapping resource="com/lsj/hibernate/User.hbm.xml"/>
		</hibernate-configuration>
	3.建立实体类
		该类对象是需要持久化的，也就是该类将会保存到数据库中，类中的每个属性就是一个字段。
		也就是说，一个表其实就是一个对象集合。
	4.建立映射
		<class-name>.xml，该配置文件一般和实体类放在同一个包下。
		<?xml version="1.0"?>
		<!DOCTYPE hibernate-mapping PUBLIC 
			"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
			"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
		<hibernate-mapping>
			<class name="com.lsj.hibernate.User">	<!-- 建立类和表的映射 -->
				<id name="<class-property>">		<!-- 建立主键对应 -->
					<generator class="uuid" />		<!-- 主键生成策略，必须提供 -->
				</id>
				
				<!-- 对象的属性和表中的字段建立映射-->
				<property name="<class-property>" />
				<property name="<class-property>" />
				...
				<property name="<class-property>" />
			</class>
		</hibernate-mapping>
		
		这样子对对象的操作，将会对应到对数据库表的操作。
	5.添加建表类，以创建表：
		这是手动法，也可以采用别的机制。
		Configuration cfg = new Configuration().configure();	//读取hibernate.cfg.xml配置文件
		SchemaExport export = new SchemaExport(cfg);			//
		export.create(true, true);		//创建表,配置文件中有类到表的映射，因此先将表创建出来。
	6.建立客户端类，添加数据：
		Configuration cfg = new Configuration().configure();
		SessionFactory factory = cfg.buildSessionFactory();		//建立session-factory, 这是数据库的镜像。
		Session session = null;			//用于进行事务
		try{
			session = factory.openSession();	//得到session
			session.beginTransaction();			//开启事务
			....
			session.save(object);				//将对象纳入session管理，在这里会在数据库中生成于之对应的主键
			session.getTransaction().commit();	//提交事务
		}catch(Exception e){
			e.printStackTrace();
			session.getTransaction().rollback();
		}finally{
			if(session != null){
				if(session.isOpen()){
					session.close();
				}
			}
		}
三、持久化对象的状态
	1.瞬时对象Transient Objects
		不在数据库中的对象，例如刚刚new的对象。不再应用这些对象时，他们的状态将会丢失，进而被垃圾回收。
		通过session.save(object)，可以将瞬时对象纳入session管理。
		* 没有被session管理
		* 在数据库中没有与之匹配的记录
		
	2.持久化对象
		具有数据库标识，并且由持久化管理器session统一管理的。session可以通过提交事务，进行和数据库的同步。
		在提交前，若对该类对象做了任何修改，都会在sql语句中体现出来。
		持久化对象，调不调用session.update没有意义。
		* 纳入session管理
		* 数据库中有与之匹配的记录（一旦save，就会在数据库中生成主键，创建于之对应的记录）
		* 当属性发送改变，在清理缓存会自动和数据同步。
		
	3.离线对象(detached)
		session关闭后，持久化对象就变为了离线对象，表示该对象不再与数据库同步。也就是说对象的状态改变时，不会同步到数据库中。
		通过session.update(object)，可以将离线对象重新纳入session管理。
		一个对象是否映射到了数据库中，主要是通过主键来判断的。对象的主键值存在于数据库中，那么该对象将映射与数据库中对应的对象。
		换句话说，可以手动创建离散对象，也就是将其主键值设置为在数据库中已经存在的主键值。
		* 没有被session管理
		* 在数据库中存在与之匹配的记录
		
四、Junit测试
	* 创建测试类，测试类继承于TestCase。
	* 编写单元测试方法，方法名称必须为test开头，方法没有参数，没有返回值。
	* 最好采用单的目录存放测试程序
	
五、关系型对象转实际对象(查询)
	只能通过主键来拿取。并且拿取下的是持久化对象。
	1.get
		执行get会马上执行一条sql查询语句。立刻返回实际对象。
		Serializable session.get(<Class>, "<primary-key-value>");	//返回的是持久化对象，也就是说它受session管理。
		若指定的数据不存在，会返回null。
	2.load
		执行load不会执行sql查询语句。返回的是代理模式，直到在使用该对象的实际数据时才执行sql查询语句，将其加载进来。
		这其实是延迟加载，只有在真正使用对象时，再加载。这样做可以提高性能。
		这里的代理采用CGLIB库生成的，而非jdk的动态代理。jdk动态代理要求类实现了接口，CGLIB代理不需要这样的约束。
		Serializable session.load(<Class>, "<primary-key-value>");
		若指定的数据不存在，还是会得到代理的，在使用代理时，会抛出ObjectNotFoundException异常。
		
六、删除与更新
	1.删除
		先获得持久化对象，再删除。
		session.delete(object);		将指定的对象从数据库中删除。
		object需要先从数据库中加载。
	2.更新
		更新是针对detached对象(离线对象)的.
		1).一般是将对象加载进来，对象进入了持久化状态，这时候根本不需要update就可以更新。
		2).若对象没有被加载进来，但是通过某种方式这个对象存在了，就需要通过update来进行加载。session.update(<detached-object>);
		
七、Query接口
	提供更丰富的查询功能。
	1.使用
		session.beginTransaction();
		Query query = session.createQuery(queryString);
		List userList = quer.list();
		...
		
	2.queryString
		可以是HQL/SQL
		HQL是Hibernate QL，因为不同的sql有不同的sql语句，而Hibernate把不同的sql封装了，用hql来提供服务。
		1.queryString=="from <class-name>"
			这样得到是对应class的所有对象，其实就是把对应表里的数据全部都拿出来了。
		2.分页
			query.setFirstResult(int);	//查找的起始位置
			quer.setMaxResult(int);		//查找的最大结果集

八、基本映射
	映射在<hibernate-mapping>标签中配置
	1.常用映射
		表-----------实体类 采用<class>标签
		表字段 ------实体类中的普通属性(不包括集合、自定义类和数组) 采用<property>标签

		注：1.如果实体类的属性名和sql中的关键词重了，将会出现错误。这种情况可以采用table属性和column属性对其在在数据库中的字段名重命名。
			2.类不能用final，因为代理是继承与类的。
			3.类最好提供标识符，例如id。
			4.setter是可以省略的，但是需要改配置。
			
	2.实体类设计原则:
		1).实现无参的默认构造函数。
		2).提供一个标识。
		3).建议不要使用final修饰实体类。
		4).建议为实体类生产getter和setter方法。
	
	3.配置文件
		<hibernate-mapping package="<package-name>">
			<class name="<class-name>" table="<table-name>">	<!-- 若没有table属性，则默认table名为class名 -->
				<property name="" column="<column-name>">		<!-- 若梅有指定column，则默认字段名用类的属性名 -->
			</class>
		</hibernate-mapping>
	4.主键标签
		1).常用属性
		<id
			name=""
			type=""		<!-- 字段在表中保存的类型 -->
			column=""
			access="field|property|ClassName"	<!-- 若设置为field，则类可以省略setter方法 -->
			
			<generator class="" />
		/>

		2).生成器策略:
			identity	自增。mysql支持，orcale不支持
			sequence	也是自增的，和上者的数据库类型不一样。orcale支持，mysql不支持。
			uuid		用一个128bit的uuid算法生成字符串类型标识符，这在一个网络中是唯一的（使用了ip地址）。
			native		根据底层数据库支持的来生成，自动使用。
			assigned	主键手动分配，即在session.save之前程序员为主键分配数值。
			foreign		使用另外一个相关联的对象的标识符。
	5.属性标签
		<property
			name=""				<!-- 属性的名字 -->
			column=""			<!-- 属性在表中的字段名 -->
			type=""				<!-- 属性在表中的字段类型 -->
			unique="true|false"	<!-- 字段值不可重复-->
			not-null="true|false"
			access="field|property|ClassName"	<!-- 若设置为field，则类可以省略setter方法 -->
		/>
九、多对一关联映射
	关联映射，就是将对象模型的关联关系映射到数据库中。
	所谓的关联关系，在对象模型中就是一个或多个引用。
	1.多对一关联映射原理
		在多的一端加入一个外键，指向一的一端。
		<many-to-one name="group" column="groupid" />	<!-- 该标签添加到多的一方 -->
			
	2.两个表的配置
		1).Group table
			<class name="com.lsj.hibernate.Group", table="t_group">
				<id name="id">
					<generator class="native">
				</id>
				<property name="name" />
			</class>
		2).User table
			<class name="com.lsj.hibernate.User"  table="t_user">
				<id name="id">
					<generator class="native">
				</id>
				<property name="name" />
				<many-to-one name="group" column="groupid" />	<!-- 在多的一段加个外键 -->
			</class>
	3.类配置
		class Group{
			String id;
			String name;
		}
		
		class User{
			String id;
			String name;
			Group group;
		}
	4.使用
		Persistent对象不能引用Transient对象。否则在commit时，发现Persistent中引用了Transient对象，是会报错的。这里的引用这的是对象所映射的表存在引用关系。
		因为引用的对象，也会在数据库中更新表，而Transient对象无法被session管理。
	5.级联(cascade)
		<many-to-one name="group" column="groupid" cascade=""/>
		hibernate会首先保存表的关联对象,这样就让关联的对象强制成为了Persistent对象。
		级联是对象之间的连锁操作，只影响添加，删除和修改。自动对关联的对象进行操作。
		all  任何行为都进行级联操作。
		none 不进行级联操作，默认
		save-update	在保存和更新时，进行级联操作。
		delete 在删除时执行级联操作。
	6.查询
		load(Class, id);可以拿到对象，若要使用引用的对象时，才会去取该引用对象的数据。这是因为load采用延迟加载策略。

十、一对一关联映射