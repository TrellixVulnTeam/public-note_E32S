一、Spring
	spring可以将依赖关系放到配置文件里，而非用代码。
	0.IoC(控制反转)
		本来由应用程序管理的对象之间的依赖关系，现在交给了容器管理，这就叫控制反转，即交给了IoC容器。
		Spring的IoC容器主要使用DI(注入)方式实现的， 对象的查找、定位和创建。
		注入，即只需类提供构造器，spring将创建好依赖的对象通过构造器将依赖对象传到当前对象中
		优势:
			* 大量减少了Factory(工厂)和Singleto(单例)的数量，使代码层次更加清晰。
			* IoC容器是轻量级容器，没有侵入性，不需要依赖容器API和特殊接口，定义的类均是POJO类。
	1.spring的依赖包配置
		* SPRING_HOME/dist/spring.jar
		* SPRING_HOME/lib/lo4j/log4j-1.2.14.jar
		* SPRING_HOME/lib/jakarta-commons/commons-logging.jar
	2.提供配置文件
		将一下配置文件放到classpath可以找到的地方, 由于src文件夹就是classpath中配置的当前目录，因此放在src下即可。
		* log4j.properties
		* applicationContext.xml
			在其中描述依赖关系，让spring负责依赖对象的注入。
			要让spring管理我们对象的创建和依赖，必须将依赖关系配置到spring的该文件中。
			<?xml version="1.0" encoding="UTF-8"?>

			<beans xmlns="http://www.springframework.org/schema/beans"
					 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					 xmlns:aop="http://www.springframework.org/schema/aop"
					 xmlns:tx="http://www.springframework.org/schema/tx"
					 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
					   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
					   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
					   
				<!-- 对产品类的信息 以及产品之间的相互依赖进行描述 -->
				<bean id="<product-name1>" class="<class-name1>"/>
				<bean id="<product-name2>" class="<class-name2>"/>
				<bean id="<product-name3>" class="<class-name3>">
					<constructor-arg ref="<product-name1>"/> 	<!-- 通过DI来获取依赖对象 -->
					<property name="<product-name-in-class>" ref="<product-name>" />   <!-- 通过getter setter获得，此时不可有构造函数 -->
				</bean>
			</beans>
	3.编程使用
		BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext.xml");
		Interface userManager = (Interface)factory.getBean("<product-name>");
		
二、常用属性注入
	1.属性初始化
		<bean id="bean1" class="com.lsj.spring.Bean1">
			<property name="strValue" value="Hello_Spring" />	<!-- 对于java自带的值类型，用value作为初始值 -->
		</bean>
		只有数值、字符串、List、Set、Map可以自动赋值。对于更多一部分的类是无法通过value设初始值的，此时需要通过转换器。转换器可以放在另外的配置文件中，以使配置文件模块坏。
	2.转换器配置
		1).转换器代码
			public class UnitilDatePropertyEditor extends PropertyEditorSupport {
				@Override
				public void setAsText(String text) throws IllegalArgumentException {
					this.setValue(new <class-name>(text));	//将字符串转换到指定的对象
				}
			}

		2).转换器配置文件
			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
					 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					 xmlns:aop="http://www.springframework.org/schema/aop"
					 xmlns:tx="http://www.springframework.org/schema/tx"
					 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
					   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
					   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">
					  
				<bean id="<self-dfine-editors>" class="org.springframework.beans.factory.config.CustomEditorConfigurer">
					<property name="cuustomEditors">	<!-- 这个那么是定了的，它是上述类中的属性，也就是说该属性是管理自定义转换器的 -->
						<map>
							<!-- 意思是转换到<class-name>需要用<editor-class-name>, spring自动会调用 -->
							<!-- 这个本质上其实就是个map属性，key值为要转换的对象，value为转换到该对象使用的转换器-->
							<entry key="<class-name>">
								<bean class="<editor-class-name>" />	<!-- value其实就是一个转换器对象，该转换器的还可以继续增加配置参数的，因为bean对象可以配置初始属性即在下面加<property>属性标签 -->
							</entry>
						</map>
					</property>
				</bean>
			</beans>
	3.多配置文件的读取
		BeanFactory factory = new ClassPathXmlApplicationContext(new String[]{"applicationContext.xml", ..});
		BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext-*.xml");	将classpath中可以匹配名字的配置文件都读入   
	4.公共配置的抽象
		通过<bean>标签，将公共的配置提取出来，放在单独的<bean>标签中，且该<bean>中的abstract属性为true
		在其他的<bean>标签中指定其parent即可。
		配置:
			<bean id="AbstractBean" abstract="true">
				<property name="<product-name>" value="<init-value>"/>
			</bean>
			<bean id="<child-id>" class="<class-name>" parent="AbstractBean">
				<property name="<product-name>" value="<init-value>"/>
			</bean>
	5.value和ref的关系与区别
		* ref属性中，应该指定依赖的bean组件。spring会在当前对象初始化时，会自动将依赖的bean组件的类初始化并注入到当前对象中。
		* value属性中，应该指定具体的某个字符串。spring会在当前对象初始化时，传入该字符串作为该属性的初始值，对于常用的属性会将字符串自动转换为对应的类型，其他情况则需要自定义转换器。
		* ref和value都是用来对属性初始化赋值的。ref是赋予的bean组件对象，value是字符串。
		
三、spring的作用域
	scope取值:
		* singleton : 默认值，每次调用getBean()向IoC容器取得对象是相同的，即相当于是该类为单例模式。
		* prototype : 每次调用getBean()向IoC容器中取得对象是不相同的。
		
四、spring自动装配
	1.根据名字匹配
		在<beans>标签中使用属性: default-autowire="byName"
		这样子对象中的应用会自动到spring的bean中进行匹配，而不用写明在配置文件中。
		匹配的方式是依赖对象的setter getter方法和依赖的bean组件的name或者id属性同名。
		如 public void setBean3(Bean3 bean3){...} 这样可以自动将id或name为bean3的组件进行注入。
	2.根据类型匹配
		在<beans>标签中使用属性: default-autowire="byType"
		bean组件的名字无所谓，而是通过依赖对象的类型到spring容器中寻找相同类型的组件。