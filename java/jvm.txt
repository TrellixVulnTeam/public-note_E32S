深入理解Java虚拟机-JVM
	java -version可以查看本机java版本信息，包括使用的jvm类型。sun jdk使用的是HotSpot虚拟机。

(一)、Java内存区域与内存溢出异常
	一、运行时数据区域
		1).程序计数器
			一块较小的内存空间，记录程序每个线程的字节码运行到的位置。这是线程私有的。
		2).虚拟机栈
			通常我们说的栈，就是指的虚拟机栈。以线程为单位，并且线程之间相互独立，是线程私有的。每个线程都有一个对应的栈帧，栈帧中的内容存储了局部变量表、操作数栈、动态链接、方法出口等信息。
			局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。64bit的long和double会占用两个局部变量空间，其余占用一个。
		3).本地方法栈
			虚拟机栈为java方法服务，而本地方法栈为native方法服务，方便和其他语言对接。HotSpot已经把本地方法栈和虚拟机栈合二为一。
		4).堆
			线程共享，在虚拟机启动时创建，堆用于存放对象实例。
		5).方法区
			线程共享，存储虚拟机加载的类信息，常量，静态变量等数据。方法区也称为【永久代】，作为gc分代管理的一部分。
			【常量池】，是方法区的一部分。用于存放编译器生成的各种字面量和符号引用，运行期也可以将新的常量放入池中。例如String的intern方法。
	二、对象的创建
		虚拟机遇到一条new指令，就开启了对象的创建过程
		1).类加载
			首先去检查这个new指令的类是否已经加载、解析和初始化到常量池。若没有则要先进行类加载过程。
		2).内存分配
			虚拟机将为新生的对象分配内存，对象所需要的内存大小在类加载完成后便可以【完全确定】。
		3).对象内存空间初值
			将分配到的内存空间都初始化为0或null。
		4).对象头初始化
			虚拟机对对象进行必要的设置，比如对象是哪个类的实例、如何找到类的元数据信息、对象的hashcode、对象的gc粉黛年龄等信息。这些信息放在对象的对象头中。
		5).构造函数执行
			到这里就可以按照程序员的意愿进行初始化了。
	三、对象的内存布局
		对象在内存中存储的布局可以分为3块区域：
		1.对象头
			对象头又分为两部分:
			1).对象自身运行时数据
				包括哈希码、gc分代年龄、锁状态标识、线程持有的锁、偏向线程的id、偏向时间戳。这部分数据为32bit(32bit机中)或64bit(64bit机中)。官方称这部分数据为Mark Word。
			2).类型指针
				对象指向它的类元数据的指针，vm用这个指针来确定这个对象是哪个类的实例。
			3).长度
				该部分数据并不普遍存在于对象中，仅存在于数组对象中，用于确定数组的长度。
		2.实例数据
			无论从父类继承的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配参数和字段在java源码中定义顺序的影响。
		3.对齐填充
			占位符作用，对象的大小必须是8字节的整数倍。
	四、对象的访问定位
		1.使用句柄
			java堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄地址包含了【对象的地址】与【对象类型数据的地址】。
		2.直接指针
			reference中直接就是对象的地址。【hotspot是使用该方法】
	五、调试设置
		-Xms/-Xmx 设置堆的最大值和最小值，如-Xms-20m -Xmx20m代表堆的大小固定为20M。
		-Xss 设置栈的大小，如-Xss128k 设置栈为128KB。
		-XX:PermSize/-XX:MaxPermSize 设置方法区大小。
		-XX:+HeapDumpOnOutOfMemoryError 当vm出现OutOfMemoryError时，会将内存堆转存为快照以便事后进行分析。

(二)、垃圾收集器与内存分配策略
	垃圾回收主要考虑：
		* 什么时候回收 (在安全点或安全区域的位置进行回收)
		* 回收哪些 (GC Roots无法引用的对象都是待回收的)
		* 如何回收
	程序计数器、虚拟机栈、本地方法栈 这几个区域由线程自己管理，是线程私有的，因此垃圾回收不考虑这几个区域。
	堆和方法去需要考虑垃圾回收
	一、对象存活判断
		1.引用计数器
			给对象添加一个引用计数器，每当一个地方引用该对象时，对象的引用计数器便+1.该方法简单高效，但是对于互引用问题 无法正确回收。
			c++的智能指针、python等一些技术里面会采用该方法。
		2.可达性分析
			通过一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有引用链的时候，该对象不可到达。
			可作为GC Roots对象的有：
				* 虚拟机栈中引用的对象。
				* 方法区中类静态属性引用的对象。
				* 方法区中常量引用的对象。
				* 本地方法栈中JNI引用的对象。
		java中的引用:
			* 强引用
			* 软引用
			* 弱引用
			* 虚引用
			可达性分析中不可到达的对象，并非一定就会被释放掉，而是会经过两次标记的过程:
				1).将没有与引用链连接的对象进行第一次标记，并将实现了finalize()方法且【没执行】过该方法的对象筛选出来，放入F-Queue队列之中。
				2).F-Queue队列中的对象 会在稍后由一个虚拟机自动建立的低优先级的Finalizer线程去执行它。finalize并不一定会执行完毕，因为若finalize特别耗时，那么vm的gc机制将会崩溃。
				3).F-Queue中的对象在进行一次标记，这样该对象就必然会被回收了。
		方法区也是需要垃圾回收的，方法区需要回收两部分的内容：废弃常量和无用类。
	二、垃圾收集算法
		1.标记-清除算法(Mark-Sweep)
			首先标记处所有需要回收的对象，然后将标记的对象统一回收。
			有两个不足:	
						* 效率低，标记和清除的效率都不高。
						* 空间问题，会产生大量不连续的内存碎片。
		2.复制算法
			将可用内存分为大小相等的两块，每次只使用其中的一块，当这一块用完了，就将还存活的对象挨个复制到另外一块上面挨个排列，然后将旧的那块一次全部清理掉。该算法要牺牲掉一半的内存，代价太高。
			现在的vm基本都是采用这种算法来回收新生代对象。因为新生代对象98%都是【朝不保夕】的，因此不需要划分50%的内存用来复制仍存在的对象。只需要留出2%的内存来保留仍可能存在的对象就够了。但是2%毕竟只是理论和平均值，实际上采用的10%的内存空间，把边界留宽松一些。
			具体来说将内存分为了一块较大的Eden和两块较小的Survivor空间，每次使用一块Eden空间和一块Survivor空间，当回收时会将活着的对象复制到另一块Survivor空间中。若Survivor空间不够用了，会从老年代对象的内存拿来保存。
		3.标记-整理散发
			常用于老年代的内存中。
			首先标记所有需要回收的对象，将存活对象整理为挨个存放，最后将不需要的对象回收。
		4.分代收集算法
			当代商业虚拟机的垃圾手机都采用分代收集算法，主要是根据存活周期的不同将内存分为新生代和老年代。
	三、算法的实现
		1.枚举根节点
			GC Roots在全局性的引用与执行上下文中，如果是逐个检查比如消耗大量时间。
			可达性分析对程序的影响会体现在GC停顿上，因为这项工作必须在一个引用关系不会变化的时间上进行。GC就会停顿所有的java执行线程，即Stop The World。
			当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机可以根据OopMap这个数据结构来指导哪些地方存放着对象引用。
		2.安全点
			在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots枚举。HotSpot并没有为每条指令都生成OopMap，只是在“特定的位置”生成的OopMap，这些位置被称为安全点。
			程序只有在安全点上才会开始GC。在安全点停止的机制也分为两种:
				* 抢占式中断:
					在发生gc时，所有线程都会中断，发现有不在安全点上的线程，则恢复对应的线程让它跑到安全点上再挂起。（现在几乎没有vm使用这个策略）
				* 主动式中断:
					各个线程在安全点回去轮询一个标志，当该标志位真就是需要gc了，线程会将自己挂起。
		3.安全区域
			安全区域指在一段代码片段中，引用关系不会发生变化，在这个区域中的任意地方开始gc都是安全的。一个线程即将离开安全区域时，会检查系统是否已经完成gc，若没完成则挂起。
	四、垃圾收集器
		1.Serial收集器
			最基本，历史最悠久的收集器。单线程意味着在进行垃圾收集时，必须暂停其他所有工作线程。该gc依然是client模式下默认的新生代收集器。
			Serial 是新生代的gc，采用复制算法。
			Serial old是老年代的gc，采用标记整理算法。
		2.ParNew收集器
			这个其实就是Serial收集器的并行版本，这个并行的意思是在gc的时候采用的是多线程方式。是Server模式下mv首选的新生代收集器。
		3.Parallel Scavenge收集器
			Parallel Scavenge 是新生代 复制算法 并发多线程的收集器。它关注与可控制的吞吐量。
			Parallel Old 是老年代收 标记-整理 多线程的收集器。
		4.CMS收集器
			一种以获取最短回收停顿时间为目标的收集器。是标记清理算法实现的。分为四个步骤:
				1).初始标记
					标记GC Roots能直接关联到的对象。这个步骤会停顿。
				2).并发标记
					标记GC Roots会引用到的对象。这个步骤不会停顿。即和普通线程一样运行。
				3).重新标记
					将在上一步骤中发生改变的引用重新标记。这个步骤会停顿。
				4).并发清除
					将标记的线程清楚。这个步骤不会停顿。
		5.G1收集器
			面向服务端应用的垃圾收集器，是当今收集器技术发展的最前沿成果之一。
	五、内存分配与回收策略
		对象主要分配在Eden区上，如果启动了本地线程分配缓冲，那么会优先在TLAB上分配。
		1.优先在Eden分配
			大多数情况下，新生代对象在Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。
		2.大对象直接存入老年代
			大对象是指，需要大量连续内存空间的Java对象。很长的字符串或者数组就是典型的大对象。
		3.长期存活的对象将进入老年代
			经过一次MinorGC后仍然存活的对象，对象年龄将会增加一。年龄增加到一定程度的时候就会移到老年代中，默认为15岁。
		4.动态对象年龄判定
			如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，那么年龄大于或等于该年龄的对象可以直接进入老年代。
		5.空间分配担保
			在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC是安全的。
			如果不成立，
				那么就查看HandlePrmotionFailure设置是否运行担保失败，若不允许，那么会检查老年代最大可用的连续空间是否大于【历次】晋升到老年代对象的平均大小，若大于这个大小，那么就尝试一次Minor GC。
				若HandlePromotionFailure不允许失败 或者 运行失败的前提下连续可用空间小于平均大小，那么就先进行一次Full GC。
	六、调试参数
		-verbose:gc 开启GC日志，输出于控制台。每当发生gc事件时便会打印。
		-XX:+PrintGCDetails 打印更完善的GC日志，也是在GC事件时打印，并在当前进程退出的时候输出当前的内存各区域分配情况。打开这个的时候，可以不用-verbose:gc。
		-XX:MaxTenuringThreshold=xx 设置对象在年龄为多少的时候会进入老年代。
(三)、类文件结构
	Class文件是一组以字节为基础单位的二进制流，中间没有添加任何分隔符。Class文件本质上就是一张表:
      类型     |          名称         |           数量           |    描述
---------------|-----------------------|--------------------------|-------------
       u4      |          magic        |  1                       |     魔数
       u2      |     minor_version     |  1                       |   次版本号
       u2      |     major_version     |  1                       |   主版本号
       u2      |   constant_pool_count |  1                       |  常量池大小
    cp_info    |     constant_pool     |  constant_pool_count-1   |    常量池
       u2      |      access_flags     |  1                       | 类的访问权限标志
       u2      |       this_class      |  1                       |     类索引
       u2      |       super_class     |  1                       |    父类索引
       u2      |    interfaces_count   |  1                       |    接口个数
       u2      |       interfaces      |  interfaces_count        |   接口集合索引
	   u2      |      fields_count     |  1                       |     字段个数
   field_info  |         fields        |  fields_count            |    字段的信息
       u2      |      methods_count    |  1
 method_info   |         methods       |  methods_count
       u2      |     attributes_count  |  1
attribute_info |       attributes      |  attributes_count
	一、魔数于class文件版本
		每个class文件的头4个直接称为魔数，用于确定这个文件是否为一个能被虚拟机接收的Class文件。魔数是magic : 0xCAFEBABE，咖啡宝贝。
		接着魔术的4个字节直接是class文件的版本号，由次版本号(minor_version)和主版本号(major_version)确定。
	二、常量池
		常量池相当于class的资源仓库。常量池的常量数是不固定的，由constant_pool_count指定。
		常量池主要存放了两大类常量:
			* 字面量
				如 文本字符串，final常量
			* 符号引用
				- 类和接口的全限定名
				- 字段的名称和描述符
				- 方法的名称和描述符
		常量池的数据类型:
			CONSTANT_Utf8_info UTF-8编码的字符串
			CONSTANT_Integer_info 整型字面量
			CONSTANT_Float_info 浮点型字面量
			CONSTANT_Long_info 长整型字面量
			CONSTANT_Double_info 双精度浮点型字面量
			CONSTANT_Class_info 类或接口的符号引用
			CONSTANT_String_info 字符串类型字面量
			CONSTANT_Fieldref_info 字符串类型字面量
			CONSTANT_Methodref_info 类中方法的符号引用
			CONSTANT_InterfaceMethodref_info 接口方法的符号引用
			CONSTANT_NameAndType_info 接口中方法的符号引用
			CONSTANT_MethodHandle_info 表示方法句柄
			CONSTANT_InvokeDynamic_info 表示一个动态方法调用点
			不同的数据类型，在常量池中的数据结构又是不同的，这里不展开了。但是所有的常量数据都有个tag标志，用于标识当前这个常量项的类型。
			很多常量类型，最后指向的都是字符串常量。
	三、访问标志
		用于识别类或接口层次的访问信息，包括该class是类还是接口，是否为public，是否为abstract。
	四、类索引、父类索引和接口索引
		类索引 和 父类索引 都是一个u2类型的数据，接口索引 是一个u2类型的数据集合。因为一个类的父类唯一，接口可以有多个。
		索引其实就是索引到常量池中的一个符号。
		类索引用于确定这个类的全限定名。
		父类索引用于确定福利的全限定名。
	五、字段表集合
		用于描述接口或类中声明的变量。字段表结构为:
		-------------|--------------------|--------------
		      u2     |    accessflags     | 1    访问标志(public/protected/private final static等等)
		      u2     |     name_index     | 1    字段名的索引(常量池中)
		      u2     |  descriptor_index  | 1    描述符的索引(常量池中)
		      u2     |  attributes_count  | 1
	  attribute_info |     attributes     | attributes_count
	  字段表集合不会列出从超类或父接口中继承而来的字段。
	六、方法表集合
		方法表集合和字段表集合的结构，完全相同。方法中的代码字节码是放在方法表的attributes中的Code属性中的。
	七、属性表集合
		Class文件、字段表、方法表都能携带自己的属性表集合。
		对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量。
		属性表抽象结构:
		|--------------------------------|
		|	u2  attribute_name_index 1   |
		|	u4  attribute_length     1   |
		|	      info                   |
		|--------------------------------|
(四)、虚拟机类加载机制
	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
	一、类加载的时机
	              ------------连接------------
				  |                          |
		加载 ---> | 验证 ---> 准备 ---> 解析 | ---> 初始化 ---> 使用 ---> 卸载
		          |                          |
				  ----------------------------
		jvm严格规定只有5种情况必须立即对【类】进行初始化:
			1.遇到new getstatic putstatic invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。
			2.使用reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
			3.当初始化一个类的时候，如果发现父类还没有进行过初始化，则需要先触发父类的初始化。
			4.当虚拟机启动时，用户需要制定一个执行的主类，jvm会对这个类先初始化。
			5.如果1个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个句柄所对应的类没有进行过初始化，则需要先初始化。
	二、类加载的过程
		1.加载
			这是【加载】是【类加载】的第一个过程，要完成3件事:
				1).通过一个类的全限定名来获取定义此类的二进制字节流。(可以使用自定义类加载器来获取二进制字节留)
				2).将这个字节流所代表的静态存储结果转化为方法区的运行时数据结构。
				3).在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
		2.验证
			是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不危害jvm只是你的安全。
		3.准备
			准备阶段是正式为类变量分配内存并设置【类变量】初始值的阶段。这里的初始值指的是数据类型的零值。
		4.解析
			解析阶段是虚拟机将常量池内的符号替换为直接引用的过程。需要注意的是，有些符号是没办法在类加载阶段就解析完毕的。类加载的时候就解析好的引用，通常是private static方法 实例变量等。
			符号引用:符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
			直接引用:直接引用可以说知己指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
			解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符。
		5.初始化
			在初始化这里，会执行类中定义的java代码。这个初始化并非对象实例化的初始化，而是类的初始化，执行static代码块。static代码块的符号是<clinit>
			需要注意的是，虚拟机会保证一个<clinit>()方法在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法。
	三、类加载器
		类加载器的作用是 通过一个类的全限定名来获取此类的二进制字节流。
		类在java中通过全限定名来唯一标识，但是在jvm得奖角度，类是通过类加载器和全限定名来唯一识别。因此不同的类加载器加载的同名类，用equals来判断是会返回false的。
		1.双亲委派模型
			1.启动类加载器
				由c++实现，负责将放在<JAVA_HOME>/lib目录中的的类库加载到虚拟机内存中。
			2.扩展类加载器
				ClassLoader的子类，用于将<JAVA_HOME>/lib/ext目录中的类库加载到jvm中。
			3.应用程序类加载器
				用于将classpath中的jar加载到jvm中。
			双亲委派模型的工作过程是，如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求都会在顶层的启动类加载器中完成。
		2.双亲委派模型的破坏
			用户自定义的类加载器，应该覆盖findClass()方法，而不能覆盖loadClass()方法，否则会破坏双亲委派模型。
			loadClass()的逻辑是调用父类加载器，无法成功加载再调用当前类的findClass()方法，因此若重写loadClass很有可能破坏掉双亲委派模型，因此应该覆盖findClass()方法。