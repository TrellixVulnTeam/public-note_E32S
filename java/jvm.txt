深入理解Java虚拟机-JVM
	java -version可以查看本机java版本信息，包括使用的jvm类型。sun jdk使用的是HotSpot虚拟机。

(一)、Java内存区域与内存溢出异常
	一、运行时数据区域
		1).程序计数器
			一块较小的内存空间，记录程序每个线程的字节码运行到的位置。这是线程私有的。
		2).虚拟机栈
			通常我们说的栈，就是指的虚拟机栈。以线程为单位，并且线程之间相互独立，是线程私有的。每个线程都有一个对应的栈帧，栈帧中的内容存储了局部变量表、操作数栈、动态链接、方法出口等信息。
			局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。64bit的long和double会占用两个局部变量空间，其余占用一个。
		3).本地方法栈
			虚拟机栈为java方法服务，而本地方法栈为native方法服务，方便和其他语言对接。HotSpot已经把本地方法栈和虚拟机栈合二为一。
		4).堆
			线程共享，在虚拟机启动时创建，堆用于存放对象实例。
		5).方法区
			线程共享，存储虚拟机加载的类信息，常量，静态变量等数据。方法区也称为【永久代】，作为gc分代管理的一部分。
			【常量池】，是方法区的一部分。用于存放编译器生成的各种字面量和符号引用，运行期也可以将新的常量放入池中。例如String的intern方法。
	二、对象的创建
		虚拟机遇到一条new指令，就开启了对象的创建过程
		1).类加载
			首先去检查这个new指令的类是否已经加载、解析和初始化到常量池。若没有则要先进行类加载过程。
		2).内存分配
			虚拟机将为新生的对象分配内存，对象所需要的内存大小在类加载完成后便可以【完全确定】。
		3).对象内存空间初值
			将分配到的内存空间都初始化为0或null。
		4).对象头初始化
			虚拟机对对象进行必要的设置，比如对象是哪个类的实例、如何找到类的元数据信息、对象的hashcode、对象的gc粉黛年龄等信息。这些信息放在对象的对象头中。
		5).构造函数执行
			到这里就可以按照程序员的意愿进行初始化了。
	三、对象的内存布局
		对象在内存中存储的布局可以分为3块区域：
		1.对象头
			对象头又分为两部分:
			1).对象自身运行时数据
				包括哈希码、gc分代年龄、锁状态标识、线程持有的锁、偏向线程的id、偏向时间戳。这部分数据为32bit(32bit机中)或64bit(64bit机中)。官方称这部分数据为Mark Word。
			2).类型指针
				对象指向它的类元数据的指针，vm用这个指针来确定这个对象是哪个类的实例。
			3).长度
				该部分数据并不普遍存在于对象中，仅存在于数组对象中，用于确定数组的长度。
		2.实例数据
			无论从父类继承的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配参数和字段在java源码中定义顺序的影响。
		3.对齐填充
			占位符作用，对象的大小必须是8字节的整数倍。
	四、对象的访问定位
		1.使用句柄
			java堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄地址包含了【对象的地址】与【对象类型数据的地址】。
		2.直接指针
			reference中直接就是对象的地址。【hotspot是使用该方法】
	五、调试设置
		-Xms/-Xmx 设置堆的最大值和最小值，如-Xms-20m -Xmx20m代表堆的大小固定为20M。
		-Xss 设置栈的大小，如-Xss128k 设置栈为128KB。
		-XX:PermSize/-XX:MaxPermSize 设置方法区大小。
		-XX:+HeapDumpOnOutOfMemoryError 当vm出现OutOfMemoryError时，会将内存堆转存为快照以便事后进行分析。

(二)、垃圾收集器与内存分配策略
	垃圾回收主要考虑：
		* 什么时候回收 (在安全点或安全区域的位置进行回收)
		* 回收哪些 (GC Roots无法引用的对象都是待回收的)
		* 如何回收
	程序计数器、虚拟机栈、本地方法栈 这几个区域由线程自己管理，是线程私有的，因此垃圾回收不考虑这几个区域。
	堆和方法去需要考虑垃圾回收
	一、对象存活判断
		1.引用计数器
			给对象添加一个引用计数器，每当一个地方引用该对象时，对象的引用计数器便+1.该方法简单高效，但是对于互引用问题 无法正确回收。
			c++的智能指针、python等一些技术里面会采用该方法。
		2.可达性分析
			通过一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有引用链的时候，该对象不可到达。
			可作为GC Roots对象的有：
				* 虚拟机栈中引用的对象。
				* 方法区中类静态属性引用的对象。
				* 方法区中常量引用的对象。
				* 本地方法栈中JNI引用的对象。
		java中的引用:
			* 强引用
			* 软引用
			* 弱引用
			* 虚引用
			可达性分析中不可到达的对象，并非一定就会被释放掉，而是会经过两次标记的过程:
				1).将没有与引用链连接的对象进行第一次标记，并将实现了finalize()方法且【没执行】过该方法的对象筛选出来，放入F-Queue队列之中。
				2).F-Queue队列中的对象 会在稍后由一个虚拟机自动建立的低优先级的Finalizer线程去执行它。finalize并不一定会执行完毕，因为若finalize特别耗时，那么vm的gc机制将会崩溃。
				3).F-Queue中的对象在进行一次标记，这样该对象就必然会被回收了。
		方法区也是需要垃圾回收的，方法区需要回收两部分的内容：废弃常量和无用类。
	二、垃圾收集算法
		1.标记-清除算法(Mark-Sweep)
			首先标记处所有需要回收的对象，然后将标记的对象统一回收。
			有两个不足:	
						* 效率低，标记和清除的效率都不高。
						* 空间问题，会产生大量不连续的内存碎片。
		2.复制算法
			将可用内存分为大小相等的两块，每次只使用其中的一块，当这一块用完了，就将还存活的对象挨个复制到另外一块上面挨个排列，然后将旧的那块一次全部清理掉。该算法要牺牲掉一半的内存，代价太高。
			现在的vm基本都是采用这种算法来回收新生代对象。因为新生代对象98%都是【朝不保夕】的，因此不需要划分50%的内存用来复制仍存在的对象。只需要留出2%的内存来保留仍可能存在的对象就够了。但是2%毕竟只是理论和平均值，实际上采用的10%的内存空间，把边界留宽松一些。
			具体来说将内存分为了一块较大的Eden和两块较小的Survivor空间，每次使用一块Eden空间和一块Survivor空间，当回收时会将活着的对象复制到另一块Survivor空间中。若Survivor空间不够用了，会从老年代对象的内存拿来保存。
		3.标记-整理散发
			常用于老年代的内存中。
			首先标记所有需要回收的对象，将存活对象整理为挨个存放，最后将不需要的对象回收。
		4.分代收集算法
			当代商业虚拟机的垃圾手机都采用分代收集算法，主要是根据存活周期的不同将内存分为新生代和老年代。
	三、算法的实现
		1.枚举根节点
			GC Roots在全局性的引用与执行上下文中，如果是逐个检查比如消耗大量时间。
			可达性分析对程序的影响会体现在GC停顿上，因为这项工作必须在一个引用关系不会变化的时间上进行。GC就会停顿所有的java执行线程，即Stop The World。
			当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机可以根据OopMap这个数据结构来指导哪些地方存放着对象引用。
		2.安全点
			在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots枚举。HotSpot并没有为每条指令都生成OopMap，只是在“特定的位置”生成的OopMap，这些位置被称为安全点。
			程序只有在安全点上才会开始GC。在安全点停止的机制也分为两种:
				* 抢占式中断:
					在发生gc时，所有线程都会中断，发现有不在安全点上的线程，则恢复对应的线程让它跑到安全点上再挂起。（现在几乎没有vm使用这个策略）
				* 主动式中断:
					各个线程在安全点回去轮询一个标志，当该标志位真就是需要gc了，线程会将自己挂起。
		3.安全区域
			安全区域指在一段代码片段中，引用关系不会发生变化，在这个区域中的任意地方开始gc都是安全的。一个线程即将离开安全区域时，会检查系统是否已经完成gc，若没完成则挂起。
	四、垃圾收集器
		1.Serial收集器
			最基本，历史最悠久的收集器。单线程意味着在进行垃圾收集时，必须暂停其他所有工作线程。该gc依然是client模式下默认的新生代收集器。
			Serial 是新生代的gc，采用复制算法。
			Serial old是老年代的gc，采用标记整理算法。
		2.ParNew收集器
			这个其实就是Serial收集器的并行版本，这个并行的意思是在gc的时候采用的是多线程方式。是Server模式下mv首选的新生代收集器。
		3.Parallel Scavenge收集器
			Parallel Scavenge 是新生代 复制算法 并发多线程的收集器。它关注与可控制的吞吐量。
			Parallel Old 是老年代收 标记-整理 多线程的收集器。
		4.CMS收集器
			一种以获取最短回收停顿时间为目标的收集器。是标记清理算法实现的。分为四个步骤:
				1).初始标记
					标记GC Roots能直接关联到的对象。这个步骤会停顿。
				2).并发标记
					标记GC Roots会引用到的对象。这个步骤不会停顿。即和普通线程一样运行。
				3).重新标记
					将在上一步骤中发生改变的引用重新标记。这个步骤会停顿。
				4).并发清除
					将标记的线程清楚。这个步骤不会停顿。
		5.G1收集器
			面向服务端应用的垃圾收集器，是当今收集器技术发展的最前沿成果之一。
	五、内存分配与回收策略
		对象主要分配在Eden区上，如果启动了本地线程分配缓冲，那么会优先在TLAB上分配。
		1.优先在Eden分配
			大多数情况下，新生代对象在Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。
		2.大对象直接存入老年代
			大对象是指，需要大量连续内存空间的Java对象。很长的字符串或者数组就是典型的大对象。
		3.长期存活的对象将进入老年代
			经过一次MinorGC后仍然存活的对象，对象年龄将会增加一。年龄增加到一定程度的时候就会移到老年代中，默认为15岁。
		4.动态对象年龄判定
			如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，那么年龄大于或等于该年龄的对象可以直接进入老年代。
		5.空间分配担保
			在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC是安全的。
			如果不成立，
				那么就查看HandlePrmotionFailure设置是否运行担保失败，若不允许，那么会检查老年代最大可用的连续空间是否大于【历次】晋升到老年代对象的平均大小，若大于这个大小，那么就尝试一次Minor GC。
				若HandlePromotionFailure不允许失败 或者 运行失败的前提下连续可用空间小于平均大小，那么就先进行一次Full GC。
	六、调试参数
		-verbose:gc 开启GC日志，输出于控制台。每当发生gc事件时便会打印。
		-XX:+PrintGCDetails 打印更完善的GC日志，也是在GC事件时打印，并在当前进程退出的时候输出当前的内存各区域分配情况。打开这个的时候，可以不用-verbose:gc。
		-XX:MaxTenuringThreshold=xx 设置对象在年龄为多少的时候会进入老年代。