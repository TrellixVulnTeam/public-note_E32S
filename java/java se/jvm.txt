深入理解Java虚拟机-JVM
	java -version可以查看本机java版本信息，包括使用的jvm类型。sun jdk使用的是HotSpot虚拟机。

(一)、Java内存区域与内存溢出异常
	一、运行时数据区域
		1).程序计数器
			一块较小的内存空间，记录程序每个线程的字节码运行到的位置。这是线程私有的。
		2).虚拟机栈
			通常我们说的栈，就是指的虚拟机栈。以线程为单位，并且线程之间相互独立，是线程私有的。每个线程都有一个对应的栈帧，栈帧中的内容存储了局部变量表、操作数栈、动态链接、方法出口等信息。
			局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。64bit的long和double会占用两个局部变量空间，其余占用一个。
		3).本地方法栈
			虚拟机栈为java方法服务，而本地方法栈为native方法服务，方便和其他语言对接。HotSpot已经把本地方法栈和虚拟机栈合二为一。
		4).堆
			线程共享，在虚拟机启动时创建，堆用于存放对象实例。
		5).方法区
			线程共享，存储虚拟机加载的类信息，常量，静态变量等数据。方法区也称为【永久代】，作为gc分代管理的一部分。
			【常量池】，是方法区的一部分。用于存放编译器生成的各种字面量和符号引用，运行期也可以将新的常量放入池中。例如String的intern方法。
	二、对象的创建
		虚拟机遇到一条new指令，就开启了对象的创建过程
		1).类加载
			首先去检查这个new指令的类是否已经加载、解析和初始化到常量池。若没有则要先进行类加载过程。
		2).内存分配
			虚拟机将为新生的对象分配内存，对象所需要的内存大小在类加载完成后便可以【完全确定】。
		3).对象内存空间初值
			将分配到的内存空间都初始化为0或null。
		4).对象头初始化
			虚拟机对对象进行必要的设置，比如对象是哪个类的实例、如何找到类的元数据信息、对象的hashcode、对象的gc粉黛年龄等信息。这些信息放在对象的对象头中。
		5).构造函数执行
			到这里就可以按照程序员的意愿进行初始化了。
	三、对象的内存布局
		对象在内存中存储的布局可以分为3块区域：
		1.对象头
			对象头又分为两部分:
			1).对象自身运行时数据
				包括哈希码、gc分代年龄、锁状态标识、线程持有的锁、偏向线程的id、偏向时间戳。这部分数据为32bit(32bit机中)或64bit(64bit机中)。官方称这部分数据为Mark Word。
			2).类型指针
				对象指向它的类元数据的指针，vm用这个指针来确定这个对象是哪个类的实例。
			3).长度
				该部分数据并不普遍存在于对象中，仅存在于数组对象中，用于确定数组的长度。
		2.实例数据
			无论从父类继承的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配参数和字段在java源码中定义顺序的影响。
		3.对齐填充
			占位符作用，对象的大小必须是8字节的整数倍。
	四、对象的访问定位
		1.使用句柄
			java堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄地址包含了【对象的地址】与【对象类型数据的地址】。
		2.直接指针
			reference中直接就是对象的地址。【hotspot是使用该方法】
	五、调试设置
		-Xms/-Xmx 设置堆的最大值和最小值，如-Xms-20m -Xmx20m代表堆的大小固定为20M。
		-Xss 设置栈的大小，如-Xss128k 设置栈为128KB。
		-XX:PermSize/-XX:MaxPermSize 设置方法区大小。
		-XX:+HeapDumpOnOutOfMemoryError 当vm出现OutOfMemoryError时，会将内存堆转存为快照以便事后进行分析。

(二)、垃圾收集器与内存分配策略
	垃圾回收主要考虑：
		* 什么时候回收 (在安全点或安全区域的位置进行回收)
		* 回收哪些 (GC Roots无法引用的对象都是待回收的)
		* 如何回收
	程序计数器、虚拟机栈、本地方法栈 这几个区域由线程自己管理，是线程私有的，因此垃圾回收不考虑这几个区域。
	堆和方法去需要考虑垃圾回收
	一、对象存活判断
		1.引用计数器
			给对象添加一个引用计数器，每当一个地方引用该对象时，对象的引用计数器便+1.该方法简单高效，但是对于互引用问题 无法正确回收。
			c++的智能指针、python等一些技术里面会采用该方法。
		2.可达性分析
			通过一系列GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有引用链的时候，该对象不可到达。
			可作为GC Roots对象的有：
				* 虚拟机栈中引用的对象。
				* 方法区中类静态属性引用的对象。
				* 方法区中常量引用的对象。
				* 本地方法栈中JNI引用的对象。
		java中的引用:
			* 强引用：普通的引用关系A a = new A()。只要强引用存在，gc永远不会回收掉被引用的对象。
			* 软引用：还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之类之中进行回收，若该回收还是没有足够的内存，才会抛出内存溢出异常。
			* 弱引用：只能生存到下一次回收之前的对象，当gc开始工作无论当前内存是否足够，都会回收掉弱引用。
			* 虚引用：...最弱类型的引用
			需要强调的是，不可到达的对象由于其不能被引用，因此不属于上面任何一种类型。上面描述的全都是可到达对象的引用，不过其引用的强弱有区别。
			可达性分析中不可到达的对象，并非一定就会被释放掉，而是会经过两次标记的过程:
				1).将没有与引用链连接的对象进行第一次标记，并将实现了finalize()方法且【没执行】过该方法的对象筛选出来，放入F-Queue队列之中。
				2).F-Queue队列中的对象 会在稍后由一个虚拟机自动建立的低优先级的Finalizer线程去执行它。finalize并不一定会执行完毕，因为若finalize特别耗时，那么vm的gc机制将会崩溃。
				3).F-Queue中的对象在进行一次标记，这样该对象就必然会被回收了。
		方法区也是需要垃圾回收的，方法区需要回收两部分的内容：废弃常量和无用类。
	二、垃圾收集算法
		1.标记-清除算法(Mark-Sweep)
			首先标记处所有需要回收的对象，然后将标记的对象统一回收。
			有两个不足:	
						* 效率低，标记和清除的效率都不高。
						* 空间问题，会产生大量不连续的内存碎片。
		2.复制算法
			将可用内存分为大小相等的两块，每次只使用其中的一块，当这一块用完了，就将还存活的对象挨个复制到另外一块上面挨个排列，然后将旧的那块一次全部清理掉。该算法要牺牲掉一半的内存，代价太高。
			现在的vm基本都是采用这种算法来回收新生代对象。因为新生代对象98%都是【朝不保夕】的，因此不需要划分50%的内存用来复制仍存在的对象。只需要留出2%的内存来保留仍可能存在的对象就够了。但是2%毕竟只是理论和平均值，实际上采用的10%的内存空间，把边界留宽松一些。
			具体来说将内存分为了一块较大的Eden和两块较小的Survivor空间，每次使用一块Eden空间和一块Survivor空间，当回收时会将活着的对象复制到另一块Survivor空间中。若Survivor空间不够用了，会从老年代对象的内存拿来保存。
		3.标记-整理散发
			常用于老年代的内存中。
			首先标记所有需要回收的对象，将存活对象整理为挨个存放，最后将不需要的对象回收。
		4.分代收集算法
			当代商业虚拟机的垃圾手机都采用分代收集算法，主要是根据存活周期的不同将内存分为新生代和老年代。
	三、算法的实现
		1.枚举根节点
			GC Roots在全局性的引用与执行上下文中，如果是逐个检查比如消耗大量时间。
			可达性分析对程序的影响会体现在GC停顿上，因为这项工作必须在一个引用关系不会变化的时间上进行。GC就会停顿所有的java执行线程，即Stop The World。
			当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机可以根据OopMap这个数据结构来指导哪些地方存放着对象引用。
		2.安全点
			在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots枚举。HotSpot并没有为每条指令都生成OopMap，只是在“特定的位置”生成的OopMap，这些位置被称为安全点。
			程序只有在安全点上才会开始GC。在安全点停止的机制也分为两种:
				* 抢占式中断:
					在发生gc时，所有线程都会中断，发现有不在安全点上的线程，则恢复对应的线程让它跑到安全点上再挂起。（现在几乎没有vm使用这个策略）
				* 主动式中断:
					各个线程在安全点回去轮询一个标志，当该标志位真就是需要gc了，线程会将自己挂起。
		3.安全区域
			安全区域指在一段代码片段中，引用关系不会发生变化，在这个区域中的任意地方开始gc都是安全的。一个线程即将离开安全区域时，会检查系统是否已经完成gc，若没完成则挂起。
	四、垃圾收集器
		1.Serial收集器
			最基本，历史最悠久的收集器。单线程意味着在进行垃圾收集时，必须暂停其他所有工作线程。该gc依然是client模式下默认的新生代收集器。
			Serial 是新生代的gc，采用复制算法。
			Serial old是老年代的gc，采用标记整理算法。
		2.ParNew收集器
			这个其实就是Serial收集器的并行版本，这个并行的意思是在gc的时候采用的是多线程方式。是Server模式下mv首选的新生代收集器。
		3.Parallel Scavenge收集器
			Parallel Scavenge 是新生代 复制算法 并发多线程的收集器。它关注与可控制的吞吐量。
			Parallel Old 是老年代收 标记-整理 多线程的收集器。
		4.CMS收集器
			一种以获取最短回收停顿时间为目标的收集器。是标记清理算法实现的。分为四个步骤:
				1).初始标记
					标记GC Roots能直接关联到的对象。这个步骤会停顿。
				2).并发标记
					标记GC Roots会引用到的对象。这个步骤不会停顿。即和普通线程一样运行。
				3).重新标记
					将在上一步骤中发生改变的引用重新标记。这个步骤会停顿。
				4).并发清除
					将标记的线程清楚。这个步骤不会停顿。
		5.G1收集器
			面向服务端应用的垃圾收集器，是当今收集器技术发展的最前沿成果之一。
	五、内存分配与回收策略
		对象主要分配在Eden区上，如果启动了本地线程分配缓冲，那么会优先在TLAB上分配。
		1.优先在Eden分配
			大多数情况下，新生代对象在Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次【Minor GC】。
		2.大对象直接存入老年代
			大对象是指，需要大量连续内存空间的Java对象。很长的字符串或者数组就是典型的大对象。
		3.长期存活的对象将进入老年代
			经过一次MinorGC后仍然存活的对象，对象年龄将会增加一。年龄增加到一定程度的时候就会移到老年代中，默认为15岁。
		4.动态对象年龄判定
			如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般，那么年龄大于或等于该年龄的对象可以直接进入老年代。
		5.空间分配担保
			在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC是安全的。
			如果不成立，
				那么就查看HandlePrmotionFailure设置是否运行担保失败，若不允许，那么会检查老年代最大可用的连续空间是否大于【历次】晋升到老年代对象的平均大小，若大于这个大小，那么就尝试一次Minor GC。
				若HandlePromotionFailure不允许失败 或者 运行失败的前提下连续可用空间小于平均大小，那么就先进行一次【Full GC】。
	六、调试参数
		-verbose:gc 开启GC日志，输出于控制台。每当发生gc事件时便会打印。
		-XX:+PrintGCDetails 打印更完善的GC日志，也是在GC事件时打印，并在当前进程退出的时候输出当前的内存各区域分配情况。打开这个的时候，可以不用-verbose:gc。
		-XX:MaxTenuringThreshold=xx 设置对象在年龄为多少的时候会进入老年代。
	七 GC策略总结
		1.Minor GC
			发生在新生代的垃圾回收动作。
			触发时间: 当Eden中无法容纳新对象时。
			java对象大部分都是朝不保夕的，触发较为频繁，采用标记-复制算法，回收速度较快。
			新对象分配在Eden空间，在Minor GC时会将Eden和一个survivor中仍然存活的对象复制到另一个survivor中，并将原本保存对象的Eden和survivor的内存清空。
			每次Minor GC存货下来的对象，其年龄加1岁，当年龄(默认15岁)大到一定程度就会将其放到老年代的内存中。
		2.Full GC
			发生在老生代的垃圾回收动作。
			触发时间：
				1).System.gc(), 建议jvm进行full gc，会增加full gc的频率，而full gc耗时较长因此能不使用就别使用。
				2).老年代空间不足。由于minor gc会将剩余的对象放到survivor，而survivor可能不够放，因此要借用老年代的空间，也就是在此时jvm会检查老年代空间是否够，如果不够了就要做一次full gc，将老年代的空间清空。
					由于这个特点，因此虽然full gc和major gc都是针对老年代的，但是基本上总会伴随一次minor gc，因此可以将full gc看作新生代和老年代均做了垃圾回收。
					但其实full gc也不会每次都有minor gc伴随，当分配一个大对象时，会将大对象直接放入老年代，此时也会检查老年代的空间是否够用，如果不够用会做full gc。
(三)、类文件结构
	Class文件是一组以字节为基础单位的二进制流，中间没有添加任何分隔符。Class文件本质上就是一张表:
      类型     |          名称         |           数量           |    描述
---------------|-----------------------|--------------------------|-------------
       u4      |          magic        |  1                       |     魔数
       u2      |     minor_version     |  1                       |   次版本号
       u2      |     major_version     |  1                       |   主版本号
       u2      |   constant_pool_count |  1                       |  常量池大小
    cp_info    |     constant_pool     |  constant_pool_count-1   |    常量池
       u2      |      access_flags     |  1                       | 类的访问权限标志
       u2      |       this_class      |  1                       |     类索引
       u2      |       super_class     |  1                       |    父类索引
       u2      |    interfaces_count   |  1                       |    接口个数
       u2      |       interfaces      |  interfaces_count        |   接口集合索引
	   u2      |      fields_count     |  1                       |     字段个数
   field_info  |         fields        |  fields_count            |    字段的信息
       u2      |      methods_count    |  1
 method_info   |         methods       |  methods_count
       u2      |     attributes_count  |  1
attribute_info |       attributes      |  attributes_count
	一、魔数于class文件版本
		每个class文件的头4个直接称为魔数，用于确定这个文件是否为一个能被虚拟机接收的Class文件。魔数是magic : 0xCAFEBABE，咖啡宝贝。
		接着魔术的4个字节直接是class文件的版本号，由次版本号(minor_version)和主版本号(major_version)确定。
	二、常量池
		常量池相当于class的资源仓库。常量池的常量数是不固定的，由constant_pool_count指定。
		常量池主要存放了两大类常量:
			* 字面量
				如 文本字符串，final常量
			* 符号引用
				- 类和接口的全限定名
				- 字段的名称和描述符
				- 方法的名称和描述符
		常量池的数据类型:
			CONSTANT_Utf8_info UTF-8编码的字符串
			CONSTANT_Integer_info 整型字面量
			CONSTANT_Float_info 浮点型字面量
			CONSTANT_Long_info 长整型字面量
			CONSTANT_Double_info 双精度浮点型字面量
			CONSTANT_Class_info 类或接口的符号引用
			CONSTANT_String_info 字符串类型字面量
			CONSTANT_Fieldref_info 字符串类型字面量
			CONSTANT_Methodref_info 类中方法的符号引用
			CONSTANT_InterfaceMethodref_info 接口方法的符号引用
			CONSTANT_NameAndType_info 接口中方法的符号引用
			CONSTANT_MethodHandle_info 表示方法句柄
			CONSTANT_InvokeDynamic_info 表示一个动态方法调用点
			不同的数据类型，在常量池中的数据结构又是不同的，这里不展开了。但是所有的常量数据都有个tag标志，用于标识当前这个常量项的类型。
			很多常量类型，最后指向的都是字符串常量。
	三、访问标志
		用于识别类或接口层次的访问信息，包括该class是类还是接口，是否为public，是否为abstract。
	四、类索引、父类索引和接口索引
		类索引 和 父类索引 都是一个u2类型的数据，接口索引 是一个u2类型的数据集合。因为一个类的父类唯一，接口可以有多个。
		索引其实就是索引到常量池中的一个符号。
		类索引用于确定这个类的全限定名。
		父类索引用于确定福利的全限定名。
	五、字段表集合
		用于描述接口或类中声明的变量。字段表结构为:
		-------------|--------------------|--------------
		      u2     |    accessflags     | 1    访问标志(public/protected/private final static等等)
		      u2     |     name_index     | 1    字段名的索引(常量池中)
		      u2     |  descriptor_index  | 1    描述符的索引(常量池中)
		      u2     |  attributes_count  | 1
	  attribute_info |     attributes     | attributes_count
	  字段表集合不会列出从超类或父接口中继承而来的字段。
	六、方法表集合
		方法表集合和字段表集合的结构，完全相同。方法中的代码字节码是放在方法表的attributes中的Code属性中的。
	七、属性表集合
		Class文件、字段表、方法表都能携带自己的属性表集合。
		对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量。
		属性表抽象结构:
		|--------------------------------|
		|	u2  attribute_name_index 1   |
		|	u4  attribute_length     1   |
		|	      info                   |
		|--------------------------------|
(四)、虚拟机类加载机制
	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
	一、类加载的时机
	              ------------连接------------
				  |                          |
		加载 ---> | 验证 ---> 准备 ---> 解析 | ---> 初始化 ---> 使用 ---> 卸载
		          |                          |
				  ----------------------------
		jvm严格规定只有5种情况必须立即对【类】进行初始化:
			1.遇到new getstatic putstatic invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。
			2.使用reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
			3.当初始化一个类的时候，如果发现父类还没有进行过初始化，则需要先触发父类的初始化。
			4.当虚拟机启动时，用户需要制定一个执行的主类，jvm会对这个类先初始化。
			5.如果1个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个句柄所对应的类没有进行过初始化，则需要先初始化。
	二、类加载的过程
		1.加载
			这是【加载】是【类加载】的第一个过程，要完成3件事:
				1).通过一个类的全限定名来获取定义此类的二进制字节流。(可以使用自定义类加载器来获取二进制字节留)
				2).将这个字节流所代表的静态存储结果转化为方法区的运行时数据结构。
				3).在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
		2.验证
			是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不危害jvm只是你的安全。
		3.准备
			准备阶段是正式为类变量分配内存并设置【类变量】初始值的阶段。这里的初始值指的是数据类型的零值。
		4.解析
			解析阶段是虚拟机将常量池内的符号替换为直接引用的过程。需要注意的是，有些符号是没办法在类加载阶段就解析完毕的。类加载的时候就解析好的引用，通常是private static方法 实例变量等。
			符号引用:符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
			直接引用:直接引用可以说知己指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
			解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符。
		5.初始化
			在初始化这里，会执行类中定义的java代码。这个初始化并非对象实例化的初始化，而是类的初始化，执行static代码块。static代码块的符号是<clinit>
			需要注意的是，虚拟机会保证一个<clinit>()方法在多线程环境中被正确的加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法。
	三、类加载器
		类加载器的作用是 通过一个类的全限定名来获取此类的二进制字节流。
		类在java中通过全限定名来唯一标识，但是在jvm得奖角度，类是通过类加载器和全限定名来唯一识别。因此不同的类加载器加载的同名类，用equals来判断是会返回false的。
		1.双亲委派模型
			1.启动类加载器
				由c++实现，负责将放在<JAVA_HOME>/lib目录中的的类库加载到虚拟机内存中。
			2.扩展类加载器
				ClassLoader的子类，用于将<JAVA_HOME>/lib/ext目录中的类库加载到jvm中。
			3.应用程序类加载器
				用于将classpath中的jar加载到jvm中。
			双亲委派模型的工作过程是，如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是委派给父类加载器去完成，每一个层次的类加载器都是如此。所有的加载请求都会在顶层的启动类加载器中完成。
		2.双亲委派模型的破坏
			用户自定义的类加载器，应该覆盖findClass()方法，而不能覆盖loadClass()方法，否则会破坏双亲委派模型。
			loadClass()的逻辑是调用父类加载器，无法成功加载再调用当前类的findClass()方法，因此若重写loadClass很有可能破坏掉双亲委派模型，因此应该覆盖findClass()方法。

(五)、虚拟机字节码执行引擎
	所有的虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。
	一、运行时帧结构
		栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈。
		每一个方法的从调用开始到执行完成的过程，都对应这一个栈帧在虚拟机栈里面从入栈到出栈的过程。在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎的所有字节码指令都只针对当前栈帧进行操作。
		栈帧结构:
				栈顶
		---------------------
		     当前栈帧
			___________
			|局部变量表|
			|----------|
			|  操作栈  |
			|----------|
			| 动态链接 |
			|----------|
			| 返回地址 |
			|__________|
		----------------------
				栈底
		1.局部变量表
			是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在javac的时候，就已经确定了方法的局部变量表有多大了。局部变量表以slot为最小单位，虽然slot的大小并没有标准，但通常都是4字节。
			虚拟机使用局部变量表完成参数值到参数变量列表的传递过程，如果是实例方法，那局部变量的首个slot默认用于方法所述对象的实例(即this)。局部变量表的slot是可重用的。
		2.操作数栈
			操作数栈的最大深度也在编译时写入到Code属性中了。当一个方法开始执行的时候，这个方法的操作数占是空的，在方法执行的过程中，会有各种字节码指令王操作数栈中写入和提取内容。
			操作数栈和局部变量表有部分区域是重叠在一起的。
		3.动态链接
			每个栈帧都包含一个指向运行时常量池中该栈帧所述方法的引用。字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数，这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转换成为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分成为动态链接。
		4.方法返回地址
			当一个方法开始执行后，只有两种方式可以退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令。二是遇到了异常。
	二、方法调用
		方法调用并不等于方法执行，方法调用阶段唯一的认为就是确定被调用的方法。
		1.解析
			所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会有一部分符号引用转换为直接引用，这种解析成立的前提是：方法在程序中真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用称为解析。
			满足【编译器可知，运行期不可变】都会被解析，主要包括静态方法和私有方法。因此只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段唯一确定调用版本。
		2.分派
			1).静态分派
				静态分派主要是指根据静态类型来确认方法调用版本。重载这一类就是属于静态分派。
			2).动态分派
				动态分派主要指根据动态类型来确认方法调用版本。动态就是动态分派。invokevirtual指令的运行时解析过程大致分为
					a).找到操作数顶的第一个元素所指向的对象实际类型，记作C
					b).如果C中找到与常量中的描述符和简单陈都相同的方法，则进行访问权限检验，如果通过则返回该方法的直接引用。如果不通过，则返回异常。
					c).否则，则按照继承关系从下往上一次对C的各个父类进行搜索和验证。

(六)、类加载及执行子系统案例
	一、tomcat
	二、字节码生成技术与动态代理
	
(七)、早期编译优化
	首先，其实javac期间是没什么优化的。
	jvm是个复杂的系统，编译期并不是那么确定的，整个jvm里面会先进行一个早期的编译得到class文件，然后在解释执行的时候，会将频繁执行的代码编译成机器代码以提高效率。因此编译发生在前端翻译期和运行期。
		前端编译器:javac
		(后端运行期编译器)JIT编译器:C1、C2编译器。
		(静态提前编译器)AOT编译器:GCJ、JET
	一、javac编译器
		编译过程：
			1).解析与填充符号表的过程
			2).插入式注解处理器的注解处理过程
			3).语义分析与字节码生成过程
		1.解析与填充符号表
			1).词法、语法分析
				词法分析是将源代码的字符流转变为token集合，token是编译过程的最小元素。
				语法分析是根据token序列构造抽象语法树的过程。
			2).填充符号表
				符号表是一组kv对表格，在语义分析中会用到。
		2.注解处理器
			提供一组插入式注解处理器的标准API在编译器对注解进行处理。
		3.语义分析与字节码生成
			1).语义分析主要任务是对结构上正确的源程序进行上下文有关性质的审查。
			2).结语法糖
				语法糖对程序功能没有影响，但是方便程序员使用，增强可读性。语言A的语法糖，是可以找到基本语法用来描述该语法的。语法糖是不能直接被解释或编译的，必须要翻译成基本的语法。
			3).字节码生成
	二、java的语法糖
		1.泛型与类型擦除
			c++与c#都是真实泛型，java是伪泛型，是因为java会将类型擦除掉，恢复成Object。
		2.自动装箱、拆箱与遍历循环。
			for(int i : list){
				...
			}
			等价于
			for(Iterator it=list.iterator(); it.hasNext()){
				int i = it.next();
			}
			因此可以遍历循环的对象需要实现Iterable接口。
		3.条件编译
			java的条件编译是利用常量来进行的。
			if(true){
				code1;
			}else{
				code2;
			}
			code2是不会进行编译的，因为永远都不会到达。
(八)、运行期优化
	当虚拟机发现某个方法或代码块的运行特别频繁时，就会吧这些代码定位【热点代码】(Hot Spot Code)。为了提高热点代码的执行效率，在运行时，虚拟机会将这些代码编译成与本地平台相关的机器码。
	一、即时编译器
		主流的jvm都包含解释器与编译器，当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，可以获得更高的执行效率。
		HotSpot迅疾中内置了两个即时编译器，Client Compiler和Server Compiler(即C1和C2)。jvm采用解释器与其中【一个】编译器直接配合的方式，可以在运行是用-client或-server来选择。
		通过启动指令，可以强制运行在届时模式(-Xint)，或是编译模式(-Xcomp，这个怕是效率比较高哦)。
	二、编译对象与触发条件
		热点代码有两类:
			* 被多次调用的方法
			* 被多次执行的循环体
		判断代码是不是热点代码，主要有两种方式:
			* 基于采样的热点探测：周期性的检测各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是热点方法。
			* 基于计数器的热点探测：为每个方法建立计数器，统计方法执行次数，若次数超过一定的阈值就认为它是“热点方法”。
		HotSpot虚拟机使用【基于计数器的热点探测】，为每个方法准备了两类计数器:【方法调用计数器】 和 【回边计数器】。
		如果不做任何设置，执行引擎并不会等待编译完成，而是继续解释器执行，知道提交编译完成的请求，这个方法的调用入口将会被系统自动改写为新的机器码入口。
		1.方法调用计数器
			并非绝对次数，而是一个相对的执行频率。当超过一定时间限度，方法的调用次数仍然不足以让它编译时，就会降计数器的值减半。这个过程称为计数器热度的衰减。这段时间称为半衰周期。热度衰减动作是在垃圾回收时顺便进行的。
		2.回边计数器
			统计一个方法中循环体代码的执行次数，这个就是绝对次数了。
	三、(运行时期)编译优化技术
		1.公共子表达式消除
			如果一个表达式E已经计算过了，并且先前计算到现在E中所有变量的值都没有发生编号，那么E的这次出现就成为了公共子表达式。
			公共子表达式可以直接用已经计算出来的值代替。
		2.数组边界消除
			并不是所有的情况都需要数组边界检查，若数组的索引是个常数，或者数组所处循环里面的索引最大值是个常数，都可以在编译期就确定数组的边界是否合法。因此可以减轻数组边界检查的压力。
		3.方法内联
			方法内联意思就是将方法体里面的内容直接用来替换方法的调用，这样不仅可以省去方法调用的消耗，而且也可以为其他优化手段建立良好的基础。对于一个虚方法，编译时期并不知道会调用哪个版本，因此需要复杂的技术来处理虚方法的内联。
			编译器在进行内联的时候，如果是非虚方法，那么直接进行内联街可以了，这时候的内联是有稳定前提保证的。
			如果是虚方法，那么会在CHA(类型继承关系分析)中，查询此方法是否有多个目标版本可以选择，如果唯一那么就直接内联。这样做其实也是不安全的，可以会临时加载到其他版本，因此若有其他版本的时候，会取消内联。
			如果有多个版本选择，那么先用第一个调用的来进行内联，直到另一个版本调用的时候才取消内联。
		4.逃逸分析
			如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化。
(九) java内存模型与线程
	与计算机高速缓存模型类似，jvm也构造了自己的缓存。
	一 内存模型
		Java线程1 <---> 工作内存1 <---> |------|
		Java线程2 <---> 工作内存2 <---> | Save |        |-------------|
		Java线程3 <---> 工作内存3 <---> | Load |  <---> | Main Memory |
		Java线程4 <---> 工作内存4 <---> |------|        |-------------|
		1.不可见性
			这个类似高速缓存的模型中，工作内存中保存了使用到的变量的主内存的副本，线程不能直接操作Main Memory，只能通过工作内存来操作内存。这样的内存模型会导致每个工作内存中的相同变量的缓存可能不一致。比如两个线程在代码中共享相同的变量，但是其实在各自的工作内存中该共享变量的值不一样。这也是不可见性造成的原因之一。
			除了高速缓存模型，为了使处理器内部的运算单元能够尽量被充分利用，处理器可能对输入的代码进行乱序执行优化，也就是重排序，这是造成不可见性的另一个原因。
		2.volatile
			可以通过声明变量的类型为volatile来保证不可见性。
			volatile可以让变量取消重排序优化，并且每次操作都会重新读取MainMemory到工作内存中，并且操作完成后会立刻放到MainMemory中。
		3 long与double变量规则
			这两个是64bit的数据，会将其拆分为两个32bit的操作。虽然内存模型运行这样的非原子操作，但是一般jvm都会将其实现为原子的。
		4 三大并发性质
			1).原子性
				指对一个或多个的变量操作是原子的，即不可分的，不能被其他线程打断的。其他的原子性可以通过lock和unlock来使用。一般通过高级封装的synchronized来实现。
			2).可见性
				指当一个线程修改了一个变量后，其他线程可以立即得到修改后的值，即是同步实时的。volatile synchronized和final都可以保证变量的可见性。
			3).有序性
				在本线程内观察内部操作顺序，所有的操作都是有序的，在一个线程观察另一个线程的操作顺序，是无序的。这是由于重排序引起的。通过volatile和synchronized来保证都是有序的。
	二 Java与线程
		java语言提供了在不同硬件和操作系统平台下对线程操作的统一处理。
		1.线程的实现
			1).使用内核线程实现
				内核线程(KLT)直接由操作系统内核支持的线程，这种线程由内核来完成线程切换。内核通过调度器对KLT调度，并负责将线程的任务映射到各个处理器上。
				但其实我们并非直接使用KLT，而是使用轻量级进程(LWP)，每个LWP都有一个KLT支持，将LWP放到KLT上来进行执行。
				缺陷:
					a).基于KLT实现，所有的线程操作如创建，同步等，都要进行系统调用在用户态和内核态频繁切换，代价较高。
					b).每个LWP都需要一个KLT支持，而每个内核的KLT是有限的，因此LWP也是有限的。不能有没被KLT加载的LWP。
			2).使用用户线程来实现
				完全建立在用户空间的线程库上，系统内核不能感知线程的存在。这种线程被称为用户线程(UT)。
			3).使用用户现场加轻量级进程混合实现
		2.Java线程调度
			使用抢占式调度的多线程系统，每个线程将由系统来分配执行时间，现场的切换不由线程本身决定。java便是采用抢占式调度。
			我们可以通过优先级来【建议】系统给某些现场多分配一些执行时间。但其实系统并不会决定性的按优先级来分配时间，系统会根据一些线程执行情况来分配执行时间。
		3.状态转换
			java线程在一个时间点，只可能有且只有一种状态：
				a).新建，创建后未启动的线程。
				b).运行，可能只在执行，也可能等待cpu为其分配时间。也就是说运行态的线程为马上运行或即将运行。
				c).无限期等待，这种线程不会被分配cpu执行时间，它必须被其他线程【显示】唤醒:
					没有Timeout的Object.wait()
					没有Timeout的Thread.join()
					LockSupport.park()
				d).限期等待，这种线程也不会被分配cpu执行时间，不过无须【显示】唤醒，当然显示唤醒也会醒：
					Thread.sleep方法
					设置Timeout的Object.wait()方法
					设置Timeout的Thread.sleep()方法
					LockSupport.parkNanos()方法
					LockSupport.parkUntil()方法
				e).阻塞
					阻塞主要指在等待锁，是线程被动的进入睡眠的，而前面两种等待是线程主动进入睡眠的。
				f).结束
					已终止线程的线程状态，线程已经结束执行。
(十) 线程安全与锁优化
	一 线程安全
		1.线程安全的5种程度(高->低)
			1).不可变
				不可变对象，一定是线程安全的。无论是对象的方法实现还是方法的调用者，都不需要再再去任何线程安全保障措施。这里指的不可变对象包括引用也不可变。
			2).绝对线程安全
			3).相对线程安全
				我们通常意义上指的线程安全，保证这个对象的方法调用是安全的。但是对一些组合调用，需要调用者做一些线程安全措施。
			4).线程兼容
				对象本身并不是线程安全的，但是可以通过调用者正确的使用(对方法的调用等引入同步)来保证对象在并发环境下安全的使用。
			5).线程对立
				调用者无论是否采取同步机制，都无法达到安全。
		2.线程安全的实现
			1).互斥同步
				常见的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。
				java里面的synchronized就是一种互斥手段。synchronized在编译后，会在代码块的边界生产monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来知名要锁定和解锁的对象。
				在执行monitorenter指令时，首先尝试获取对象的锁，把锁对象的计数器加1，在执行monitorexit时，会释放对象的锁，把锁对象的计数器减1.
				synchronized相同的锁对象对于同一个线程来说是可重入的。
				除了synchronized以外，也可以通过ReentrantLock来实现互斥同步，ReentrantLock具备更丰富的功能，和更好的并发性(挂起和恢复的时间比synchronized快)。
				简单来说，ReentrantLock 和 synchronized相比具有相同的并发性和语义，除此外还包含中断锁等候和定时锁等候，即阻塞的线程在指定时间内依然无法获得锁，那么就会自动放弃该锁。
				更进一步，synchronized是在jvm层面的实现，ReentrantLock是在代码上实现的，因此无法自动释放锁，要显示的使用lock()和unlock()。高并发下，ReentrantLock的性能通常更好。
			2).非阻塞同步
				互斥同步的问题是阻塞和恢复的效率较低，也称为阻塞同步。还有一种非阻塞同步，是基于冲突检测的乐观并发策略。
				通俗的说，就是先操作，如果没有其他线程争用共享数据那操作就成功，如果有争用那就采取补偿措施，比如不断地重试直到成功为止。这种机制并不需要把线程挂起，redis的事物机制也是属于这类。
				这样的策略，需要硬件的支持，需要保证【操作和冲突检测】的原子性。
			3).无同步方案
				使用ThreadLocal或是局部变量，线程之间不进行共享时间，那么自然是线程安全的。
	二 锁优化
		这些机制的目的是为了提升同步程序的执行效率。首先需要认识到synchronized之所以低下是因为【挂起线程】和【恢复线程】需要转入内核态完成。这些操作的开销较大。
		1.自旋锁与自适应自旋
			知道了synchronized低效是因为挂起线程和恢复线程引起的，又考虑到很多这样的同步操作其实执行的时间很短，例如一些setter方法。为了这么短的时间而将线程转入内核态消耗太大。
			因此线程会先进行【自旋】等待，然后查看是否锁开了，若锁开了就持有锁进行操作。自旋等待类似一个while循环，因此当锁的时间太长如果持续自旋那么会白白消耗cpu资源。因此当自旋超过了一定的次数，就会进行线程挂起，走传统流程。
			自适应自旋锁，不会固定自旋次数，而是根据上一次在这个锁上的自旋情况来决定当前的自旋的次数。
		2.锁消除
			对于某些同步代码块，被jvm检测到不可能存在数据竞争的锁进行消除。
			虽然程序员自己知道不会给不竞争的代码块加锁，但是java在编译的时候自己会给一些操作进行加锁。例如s1+s2+s3，等价于s.append(s1);s.append(s2);s.append(s3);而append方法是有加锁的。
			对一些栈上的变量也会引入一些加锁，通过锁消除，可以得知这些栈上的变量是不可能溢出的，因此会消除里面涉及到的锁。
		3.锁粗化
			当jvm检测有顺序上连续的零碎同步代码时，会将这些加锁进行粗化扩大其范围，进而把这些零碎操作都包括到一个同步代码块中。
		4.轻量级锁
			在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
		5.偏向锁
			在没有多线程竞争的前提下，进一步减少传统锁带来的消耗。更具体的说是将整个同步操作都略掉了。
			这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁都没有被其他线程获取，则持有偏向锁的线程将永远不需要同步。