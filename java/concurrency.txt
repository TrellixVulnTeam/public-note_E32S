一、简介
	线程的优势:
		1.发挥多处理器的强大功能
		2.建模简单
		3.异步事件的简化处理
		4.界面响应
	线程的风险
		1.安全性问题
			本质就是竞争问题。
		2.活跃性问题
			当某个需要执行的操作无法执行时，就引发活跃性问题。在串行程序中，死循环就是典型的活跃性问题。在并发中活跃性问题更常易发生，例如死锁。
		3.性能问题
			由活跃性问题引申出来的，活跃性问题解决了(需要执行的东西终会执行)，但是解决的不够好(等待太长)，那么就会带来大量的性能损失。
二、线程安全性
	线程安全的代码，核心在于要对【共享且可变】对象的状态访问操作进行管理。
	对象状态: 对象实例域或静态域的数据，这里面包括其他依赖对象的域。若将对象看做是多叉树，每个域是个节点，那么叶节点就是对象的状态。
	共享：意味着对象可以有多个线程同时访问。
	可变，意味着对象的值在生命周期类是可以改变的。（即对象改变）
	解决对象的线程问题，归结为3点:
		a).不在线程之间共享对象。
		b).将变量修改为不可变的。
		c).在访问对象方法时，使用同步。
	1.线程安全型
		一个类的线程安全性，是指它不过运行时采用何种调度，这些线程如何交替执行，在对象外的代码中不需要任何的同步或协同操作，这个类都将表现出【正确】行为，那么就是线程安全的。
		【正确】一词的解释是：满足人为规定的不变性条件 和 后验条件。
		更具体的说，不变性条件是认为逻辑上施加给类中状态的约束，比如类中有int min和int max两个变量，人为约束min是小于max的，不管对象的方法做了什么操作，都不应该违背这个约束。
		因此若有更新min和max的操作，一定要小心，因为若不做同步，很可能违背这个正确性，比如if(i<max){min=i}和if(j>min){max=j}，若min=0， max=5， i=5， j=3，这里若设置min=5前线程被切换到max=3后，由于3>min，因此会执行max=3，然后再切换回去执行min=5，这样不变形条件就错了。
	2.原子性问题
		原子性问题，是一个操作的最小单元。有两种常见需要压缩为原子操作的情形
		1).先检查后执行
			典型的例子是延迟初始化:
			public Object getInstance(){
				if(instance == null){
					instance = new Object();
				}
				return instance;
			}
			很明显，当instance==null进入if条件后，线程切换，次数instance还是null，而新的线程也进行这个判断，生成了新的object并且返回该object，此时反回到了原来的线程，此时会重新再new一个instance出来。
		2).读取-修改-写入
			如i++操作，就蕴含了读取值，修改值，写入值的3个操作。
		这些操作都是原子操作，在操作过程中，忌讳其他线程进行修改，因此需要用同步。
	3.加锁机制
		在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束， 因此当更新一个变量时，需要在同一个原子操作中对其他变量进行更新。
			* synchronized
				java提供了锁机制来支持原子性，首先需要了解到，每个对象中都有个锁计数器，用于支持锁机制。
					synchronized(object){
						....
					}
				当线程进入了该代码块，若对象的锁计数器为0，线程会获得object对象的锁，object的锁计数器会+1，并且记录锁的拥有者线程。当退出某个对象的同步代码块时，锁计数器减一。
				当线程进入了该代码块，若对象的锁计数器不为0，且拥有者线程为本线程，锁计数器会继续加1。这又被称为锁的重入。
				当线程进入了该代码块，若对象的锁计数器不为0，且拥有者不是本线程，那么阻塞，直到锁计数器为0。
				public synchronized void service(){
					...
				}
				等价于，即拿到本对象的锁
				public void service(){
					synchronized(this){
						...
					}
				}
				synchronized是个重量级的锁，尽量缩短其代码块范围。
三、对象的共享
	对象的共享，主要是了解如何共享和发布对象，从而是它们能够安全地由多个线程同时访问。
	1.可见性
		通常，我们无法确保执行读操作的线程能及时的看到其他线程写入的值。这是因为其他线程线程将值写入内存，而读操作内存有可能不是从内存里面直接读取的，而是编译器经过了优化从缓存里面读取，或者经过了重排序，而无法得到正确的值。这样的问题称为可见性问题。
		为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。在没有同步的情况下，编译器、处理器以及运行时都看对操作的执行顺序进行意想不到的调整。
		虽然没有同步，而可能造成失效值，但至少值是有一个初始值的，这种安全性是最低安全性的。但64bit数值变量的操作的读写操作都不是原子操作，而是2个32bit的操作。因此共享可变的long和double变量是不安全的，需要用同步或是volatile.
	2.volatile
		使用synchronized加锁，是可以让变量可见的，但是这样太重了，对于一般的变量可以用volatile声明。编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
		volatile也不会被缓存在寄存器或者其他处理器看不见的地方。volatile的变量其同步的可读性不够高(因为不用加同步代码块)，volatile可以用来确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及【标识】一些重要的显存声明周期事件的发生。主要还是标识用。
	3.发布与溢出
		发布一个对象，是指使对象 能够在当前作用域之外的代码中使用，比如一个私有对象通过get方法返回出去，这样就到了其他作用域了。当某个不应该发布的对象发布出去了，就成为逸出。
		当发布一个对象的时候，在该对象非私有域的所有对象同样会被发布，比如发布了一个map，map里面的所有kv都被发布出去了就。
		当一个对象逸出后，必须假设某个类或线程可能会误用该对象，这是肯定的，不能保证外面的代码会怎么对待这个对象。这就是使用封装的主要原因，避免逸出现象。
		* 安全的对象构造过程
			在构造过程中，如果使用内部类的技术，很有可能会造成this对象逸出。因为若在构造返回之前，就有什么别的原因，由其他线程触发了这个内部类中的方法调用，而此时由于构造函数还未完成，会造成不可预测的结果。
			因此安全的方法是将构造函数用private封装起来，由类的static函数进行构造，避免this在构造完成之前逸出。
			public class SafeListener{
				private final EventListener listener;
				private SafeListener{
					listener = new EventListener(){
						public void onEvent(Event e){
							do(e);
						}
					}
				};
				
				public static SafeListener newInstance(EventSource source){
					SafeListener safe = new SafeListener();
					source.registerListener(safe.listener);
					return safe;
				}
			}
	4.线程封闭
		将数据封闭到线程内部，就可以不用进行同步了，主要避免对象不小心从哪里逸出出去。
		1).ad-hoc线程封闭
			维护线程封闭性的职责由程序来承担，这种封闭非常脆弱，很少使用。
		2).栈封闭
			超简单，就是指建立局部变量，变量将由虚拟机栈维护。
		3).ThreadLocal类
			栈封闭终究有些不方便，要在单线程内使用一些全局的变量，就没办法了，必须要通过方法传参的方式，这终究有些不便，直接用全局变量又容易逸出，解决方法是用ThreadLocal类。
			这个类相当于是一个Map<ThreadId, Object>，里面保存了当前线程的全局变量，需要用到时则取出来，比如jdbc的connection，它的构造非常低效，因此创建一次就够了，后面需要反复使用，而又不能在哪里使用就在那里涉及的方法调用链中加参数，这样太麻烦了，就用ThreadLoca全局提供即可。
			ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>(){
				public Connection initialValue(){
					return DriverManager.getConnection(DB_URL);
				}
			};
			通过connectionHolder.get()，可以获得里面的值。
			当线程终止时，ThreadLocal对应线程里面的对象，全部都会清空。
	5.不可变对象
		之前的种种问题，都与状态【可变】相关，如果状态【不可变】那么也就没有这些问题了。如果某个对象在创建后状态就不能被修改，那么对象就成称为不可变对象。
		不可变对象，一定是线程安全的。但需要注意的是，【不可变对象】与【不可变对象的引用】两者是有区别的，保存在不可变对象中的状态虽然没法更新，但是引用可以更新，也就是创建新的不可变对象来更新。
		满足一下条件的对象才是不可变的:
			* 对象创建以后状态就不能修改
			* 对象的所有域都是final类型
			* 对象是正确创建的(构造期间，this引用没有溢出)
		由于是通过改变【不可变对象的引用】来更新状态的，引用是多个线程共享的，因此需要声明引用类型为volatile。
	6.安全发布
		1).安全发布的常用模式
			* 在静态初始化函数中初始化一个对象引用
			* 将对象的引用保存到volatile类型的域中
			* 将对象的引用保存到某个正确构造对象的final类型的域中
			* 将对象的引用保存到一个由锁保存的域中
		2).安全的共享对象
			* 线程封闭: 直接不用共享，就安全了。
			* 只读共享: 就是不可变对象或者事实不可变对象。
			* 线程安全共享: 线程安全的对象在其内部实现同步，可以由多个线程通过接口来访问而不需要进一步同步。
			* 保护对象
四、对象的组合
	1.设计线程安全的类
		设计线程安全类的步骤：
			- 找出构成对象状态的所有变量
			- 找出约束状态变量的不变性条件
			- 建立对象状态的并发访问管理策略
		1).收集同步需求
			主要是确保不变性条件不会在并发访问的情况下被破坏。如果一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时都必须持有保护这些变量的锁。
		2).依赖状态的操作
			如果在某个操作中含有基于状态的先验条件(就是依赖之前的状态条件)，那么这个操作就称为依赖状态的操作。注意这里说的状态并非是依赖的之前的值，而是一些客观条件。
			比如打印机的工作需要依赖相关初始化已经完成，相关初始化已经完成，就是一个客观的状态条件。再比如阻塞队里的中出队，要求队列中有数据，否则阻塞等待。
			并发程序一定要【等到】先验条件为真，然后再执行该操作。【等到】的含义就是阻塞。
		3).状态所有权
			容器类主要表现出“所有权”分离的形式，容器类拥有自身的状态，而客户代码拥有容器中各个对象的状态。
	2.非线程安全对象的使用(实例封闭)
		1).将对象封闭到局部
			主要是指将对象封闭在方法中使用(局部变量)，或是封闭在线程中(ThreadLocal)
		2).将对象用锁进行封闭
			监视器模式可以将对象的所有可变状态都封装起来，并由锁来保护。这个可变状态都是一些非线程安全对象或线程安全对象的组合。
	3.线程安全对象的使用
		线程安全对象并非万能的，只能保证对象方法本身是线程安全的，也就是每个方法的执行都不会改变其不可变性。
		但是客户端在使用的时候，往往会给其添加其他的不可变性，最明显的例子就是递增方法和CAS。此时只能通过加锁的方式来提供这些不可变性的方法。
		1).客户端加锁
			直接在要使用的类中添加synchronized方法，来确保新的不可变性。主要的问题是synchronized不知道使用什么来进行加锁。因为无法确定该线程安全对象实现时是通过什么对象来加锁的。
			也因此，一般会考虑到将对该对象涉及的方法全部用一个新锁来进行封装。此时可以考虑使用下面的代理模式来实现。
		2).代理模式
			将代理类继承要使用的类，重写里面的public方法并添加自己的锁即可。
	4.对象的组合方式(线程安全性委托)
		1).状态变量独立
			状态变量就是这些安全或不安全的对象，若这些变量彼此是独立的，那么组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。
		2).当委托失效时
		3).发布底层的状态变量

五、基础构建模块
	1.同步容器类
		同步容器主要用两种Vector和Hashtable。
		实现线程安全的方式是：将状态封装起来，并对每个公用方法都进行同步，使得每次只有【一个】线程可以访问容器的状态。
		虽然同步容器类是线程安全的， 但是如果涉及到【复合操作】，还是需要考虑加锁。复合操纵往往会带来新的不可变性约束。
		加锁需要考虑在使用什么锁，由于同步容器类内部的方法加锁使用的就是对象自己的锁，因此就用该对象进行加锁即可。
		public Object getLast(Vector list){
			synchronized(list){
				int lastIndex = list.size() - 1;
				return list.get(lastIndex);
			}
		}
		需要注意的是，对于同步容器类的迭代操作都需要进行加锁，否则会有竞争问题！！！
		尤其是对迭代器的使用，需要考虑加锁。其实这样大大的降低了性能，因为如果容器规模很大，加锁会对其他线程带来阻塞时间过长的缺点。
	2.并发容器类
		并发容器是Java5.0引入的，并发容器用于改善同步容器类的性能，因为同步容器类对线程进行了串行化。并发容器对于并发读操作是不会进行加锁的。
		其实并发容器就是一种采用了【读写锁】的容器。
		并发容器类有：ConcurrentHashMap、ConcurrentLinkedQueue、CopyOnWriteArrayList等等。
		并发容器类的迭代器不会抛出ConcurrentModificationException异常，因此不需要在迭代过程中对容器进行加锁。返回的迭代器具有【弱一致性】。
		弱一致性的迭代器可以容忍并发的修改，都能创建迭代器时会遍历已有的元素，并可以在迭代器构造后将修改操作反映给容器。
		由于并发容器并非单纯的用加锁来独占访问，因此客户端无法使用加锁来创建新的原子操作。如果要加锁，那么就只能全部加锁，这样会导致退化为同步容器。
	3.生产者消费者模式
		阻塞队列提供可阻塞的put和take方法，以及支持定时的offer和poll方法。
		如果队列已满，那么put方法会阻塞直到有空间可用。
		如果队列为空，那么take方法会阻塞直到有元素可用。
		阻塞队列用于实现生产者-消费者模式。【线程池】就是最典型的案例。
		BlockingQueue是这样的一个接口，有LinkedBlockQueue和ArrayBlockQueue两种实现。
	4.阻塞方法与中断方法
		当线程阻塞时，它通常处于被挂起，并且处于三种可能的阻塞状态:
			- BLOCKED，由于同步原因阻塞(进入了一个被上锁的synchronized)，这样会等待锁恢复为止。是被动的阻塞。
			- WATING，由于调用某个需要等待的方法而引起的阻塞，比如wait()方法，这样会等待其他线程将其唤醒或是该方法执行完毕。是主动的阻塞。
			- TIME_WATING，和WAITING类似，但是阻塞时间有限制，比如sleep()方法。是主动的阻塞。
		每个线程都有一个boolean类型的属性，表示线程的中断状态。Thread提供了interrupt方法，用于设置某个线程的中断状态。
		当在线程中调用一个将抛出InterruptException异常的方法时，一般有两种基本的处理选择：
			- 将该异常继续向上抛出，以向上一层的调用中说明当前阻塞遇到了中断。
			- 忽略中断继续执行。通过Thread.currentThread().interrupt()可以重置线程的中断位。
	5.同步工具类
		1).闭锁
			闭锁用于确保线程在满足条件的情况下才继续运行，否则阻塞等待。
			Java使用CountDownLatch实现了闭锁，该类可以使一个或多个线程等待一组事件发生。
			闭锁的本质是一个计数器，计数器初始化为一个正数，每当一个事件发生闭锁的计数减一，而闭锁的await方法会阻塞线程直到计数到0为止。
			CountDownLatch gate = new CountDownLatch(n);
			thread1: gate.await();		//阻塞，直到gate内部计数器到0.
			thread2: gate.countDown();	//计数器减1.
			在实际使用过程中，常常会使用双闭锁的策略。一个是起始门，另一个是结束门。
			起始门用于主线程协调所有的任务线程同时执行任务，结束门用于告知主线程所有的任务线程已经完成。
		2).FutureTask
			FutureTask<T>是一个包装器，它包装了一个Callable<T>，并且FutureTask<T>实现了Runnable和Future<T>接口。
			也就是说，FutureTask<T>将一个Callable<T>转化为了Runnable(FutureTask<T>就是Runnable)，可以直接通过这个FutureTask<T>对象来获得Callable<T>的返回值。
			FutureTask<T>实现了Runnable，因此可以交给Thread.run()方法运行。
			FutureTask<T>实现了Future<T>，因此可以通过get()方法获得结果。当任务运行完成，直接获得结果，否则阻塞直到任务完成或是抛出异常。
			可以通过FutureTask<T>来表示一些任务结果。更进一步，可以作为缓存避免反复计算相同的任务。
		3).信号量
			计数信号量，用于控制同时访问某个特定资源的操作数量。许可的初始数量通过构造函数来制定。
			acquire()方法将阻塞到有许可。
			release()方法将增加许可。
			二元信号量又称为互斥信号量，是互斥锁的基本实现。
		4).栅栏
			栅栏用于进行线程之间的协调，用于等待其他线程。
			CyclicBarrier是其Java实现。当现场到达栅栏位置时，将调用await()方法，该方法将阻塞线程知道所有线程都到达栅栏位置(也就是都调用了await方法)。
			await将会被超时和中断打断。
	6.构建高效且可伸缩结果缓存
		缓存接口应该和Map的接口类似：
		interface IMemoizer<K, V>{
			V get(K key, Callable<V> callable);		//当key不存在于缓存中时，将会使用Callable进行计算并将结果缓存。
		}

		class Memorizer<K, V> implements IMemoizer<K, V>{
			private final Map<K, FutureTask<V>> map = new ConcurrentHashMap<>();		//通过FutureTask表示计算缓存结果或者是任务。

			@Override
			V get(K key, Callable<V> callable){
				FutureTask<V> future = map.get(key);
				if(future == null){
					newfuture = new FutureTask<V>(callable);
					future = map.putIfAbsent(key, newfuture);			//没有该任务时添加新任务，若有了则不会添加新任务并且会返回老任务。
					if(future == null){									//没有老任务
						future = newfuture;
					}
				}
				return future.get();
			}
		}
九、图形用户界面应用程序
	GUI线程由EventQueue来进行管理，EventQueue中实现了一个队列，可以将事件添加进去，并且其中有个EDT(Event Dispatch Thread, 事件分发线程)用于读取队列中的任务，并进行执行。
	这个EventQueue的EDT类似一个只有1个线程容量的线程池。
	1.swing单线程
		如果gui使用多线程，容易产生竞争，死锁等问题，因此采用单线程来进行。如果程序员需要使用多线程时，应该自行实现。下面实现一个Swing工具：
		public class GuiExecutor extends AbstractExecutorSevice{
			private static final GuiExecutor instance = new GuiExecutor();	//单例
			private GuiExecutor(){}
			public static GuiExecutor instance(){ return instance;}
			public void execute(Runnalbe r){								//gui框架执行任务r，这个r应该是和gui框架紧密结合的
				if(SwingUtilities.isEventDispatchThread()){					//如果当前线程就是gui框架的单线程，则直接执行.
					r.run();
				}else{														//如果当前线程是其余线程，则将该任务放到队列中，而后交由EDT处理。
					SwingUtilities.invokeLater(r);
				}
			}
		}
	2.短时间gui任务
		短时间任务非常简单，可以直接执行解决，不会带来gui框架响应迟钝的情况。
		button.addActionListener(new ActionListener(){
			@Override
			public void actionPerformed(ActionEvent e){
				doShortTimeTask();
			}
		});
	3.长时间gui任务
		长时间任务如果直接运行，那么会很严重人机交互效果，有明显的迟钝现象。因此需要开启多线程，由另一个线程处理，处理的结果需要再交给gui框架进行渲染。
		1).多线程处理
			ExecutorService backgroundExec = Executors.newCachedThreadPool();		//线程池，用于执行多线程任务。

			button.addActionListener(new ActionListener(){
				@Override
				public void actionPerformed(ActionEvent e){
					button.setEnable(false);
					backgroundExec.exec(new Runnable(){
						@Override
						public run(){
							Object obj = doLongTimeTask();
							SwingUtilities.invokeLater(new Runnalbe(){
								obj结果渲染
								button.setEnable(true);
							});
						}						
					});
				}
			});
		2).可以取消的多线程处理
			ExecutorService backgroundExec = Executors.newCachedThreadPool();		//线程池，用于执行多线程任务。

			Future<?> runningTask = null;	//线程封闭
			startButton.addActionListener(new ActionListener(){
				@Override
				public void actionPerformed(ActionEvent e){
					startButton.setEnable(false);
					runningTask = backgroundExec.submit(new Runnable(){
						@Override
						public void run(){
							try{
								Object obj = doLongTimeTask();
							}finally{		//不管是被打断，还是停止了，都执行finally
								SwingUtilities.invokeLater(new Runnalbe(){
									startButton.setEnable(true);
								});
							}							
						}
					});
				}
			});

			cancelButton.addActionListener(new ActionListener(){
				@Override
				public void actionPerformed(ActionEvent e){
					if(runningTask != null){
						runningTask.canncel(true);
					}
				}
			});
十一、性能与可伸缩性
