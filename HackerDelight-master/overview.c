//overview:
#include "overview.h"

//==============================================================
//=====================      一、基础     ======================
//==============================================================

//===============================================================
//======================   二、2的幂边界   ======================
//===============================================================
//1) 舍入到2的幂的倍数
//下舍入到2的N次幂的倍数
int DOWN_K2POWER(int x, int N)
{
	return x&(-(1<<N));
}

//上舍入到2的N次幂的倍数
int UP_K2POWER(int x, int N)
{
	return (x+(1<<N)-1)&(-(1<<N));
}

//2) 舍入到2的幂
//下舍入到2的幂
int flp2(int x)
{
	x = x|(x>>1);
	x = x|(x>>2);
	x = x|(x>>4);
	x = x|(x>>8);
	x = x|(x>>16);

	return x-(x>>1);
}

//下舍入到2的幂，当1较少时算法速度较快
int flp2_cyc_easyOne(int x)
{
	int y=0;
	do{
		y = x;
		x = RIGHT_BIT_SET_ZERO(x);	//将x最右边的1置为0
	}while(x!=0);
	return y;
}

//下舍入到2的幂，当前导0较少时，算法速度较快
int flp2_cyc_easyNlz(int x)
{
	unsigned int y = 0x80000000;
	while(y>x)
		y=y>>1;
	return y;
}

//上舍入到2的幂
int clp2(int x)
{
	x = x-1;
	x = x|(x>>1);
	x = x|(x>>2);
	x = x|(x>>4);
	x = x|(x>>8);
	x = x|(x>>16);
	return x+1;
}

//===============================================================
//======================     三、位计数    ======================
//===============================================================
//1)1位计数
//基于二分法的1位计数
int pop(unsigned int x)
{
	x = (x&0x55555555) + ((x>>1)&0x55555555);
	x = (x&0x33333333) + ((x>>2)&0x33333333);
	x = (x&0x0F0F0F0F) + ((x>>4)&0x0F0F0F0F);
	x = (x&0x00FF00FF) + ((x>>8)&0x00FF00FF);
	x = (x&0x0000FFFF) + ((x>>16)&0x0000FFFF);
	
	return x;
}

//pop的优化
int pop_easy(unsigned int x)
{
	x = x - ((x>>1)&0x55555555);
	x = (x&0x33333333) + ((x>>2)&0x33333333);
	x = (x+(x>>4))&0x0F0F0F0F;
	x = x + (x>>8);
	x = x + (x>>16);
	
	return x&0x0000003F;
}

//2)前零计数
//普通前零计数
int nlz(int x)
{
	int n=0, y=x;

	while(1)
	{
		if (x<0)	return n;
		if (y==0)	return 32-n;
		n = n+1;
		x <<= 1;
		y >>= 1;
	}
}

//基于2分法的前零计数
int nlz_2dic(unsigned x)
{
	int n=0;
	unsigned y=0;

	n=32;
	y = x>>16; if(y!=0){n=n-16; x=y;}		//y!=0, 说明最高位1在x的左16bit中，否则在右16bit中
	y = x>>8;  if(y!=0){n=n-8;  x=y;}		//y!=0, 说明最高位1在x的左24bit中，否则在右8bit中
	y = x>>4;  if(y!=0){n=n-4;  x=y;}		//y!=0, 说明最高位1在x的左28bit中，否则在右4bit中
	y = x>>2;  if(y!=0){n=n-2;	x=y;}
	y = x>>1;  if(y!=0) return n-2;

	return n-x;
}

//===============================================================
//======================  四、整数初等函数 ======================
//===============================================================

//===============================================================
//======================     六、字搜索    ======================
//===============================================================
//第一个零字节所在的位置
unsigned int zbytel_nlz(unsigned int x)
{
	unsigned int y;

	y = (x&0x7F7F7F7F) + 0x7F7F7F7F;
	y = ~(y|x|0x7F7F7F7F);
	
	return nlz(y)>>3;
}

//指定长度的1位串所在位置
unsigned int ffstr1_nlz(unsigned int x, unsigned int n)
{
	unsigned int k, p;		//p记录位置，k缓冲移位长度

	p=0;
	while(x!=0)
	{
		k = nlz(x);			//前导0长度，直接舍去
		x = x<<k;	p+=k;
		k = nlz(~x);		//前导1长度，是否满足条件。满足，返回。不满足，直接舍去。
		if (k>=n)	return p;
		x = x<<k;	p+=k;
	}

	return 32;
}

//===============================================================
//======================     七、位反转    ======================
//===============================================================
//1)位反转
//32bit的位反转
unsigned int BitRev_32BIT(unsigned int x)
{
	x = ( (x&0x55555555)<<1 | (x>>1)&0x55555555 );					//完成时，已将x中2个位的数据交换
	x = ( (x&0x33333333)<<2 | (x>>2)&0x33333333 );					//完成时，已将x中4个位的数据交换
	x = ( (x&0x0F0F0F0F)<<4 | (x>>4)&0x0F0F0F0F );					//完成时，已将x中8个位的数据交换，即每个字节的8bit数据进行了反转
	x = (x<<24) | ((x&0xFF00)<<8) | ((x>>8)&0xFF00) | (x>>24);		//完成时，已完成了32bit的数据反转
	return x;
}

//广义位反转
unsigned int BitRev_Broad(unsigned int x, int k)
{
	if (k&1) x = ( (x&0x55555555)<<1 | (x>>1)&0x55555555 );
	if (k&2) x = ( (x&0x33333333)<<2 | (x>>2)&0x33333333 );
	if (k&4) x = ( (x&0x0F0F0F0F)<<4 | (x>>4)&0x0F0F0F0F );
	if (k&8) x = ( (x&0x00FF00FF)<<8 | (x&0xFF00FF00)>>8 ); 
	if (k&16)x = ( (x&0x0000FFFF)<<16| (x&0xFFFF0000)>>16);	//将x的左右两个字节对跳
	
	return x;
}

//2)位混洗
//外全混洗
unsigned int PerfectShuffle_OUT(unsigned int x)
{
	x = (x&0x0000FF00)<<8 | (x>>8)&0x0000FF00 | x&0xFF0000FF;
	x = (x&0x00F000F0)<<4 | (x>>4)&0x00F000F0 | x&0xF00FF00F;
	x = (x&0x0C0C0C0C)<<2 | (x>>2)&0x0C0C0C0C | x&0xC3C3C3C3;
	x = (x&0x22222222)<<1 | (x>>1)&0x22222222 | x&0x99999999;
	return x;
}

//内全混洗
unsigned int PerfectShuffle_IN(unsigned int x)
{
	x = BitRev_Broad(x, 16);
	return PerfectShuffle_OUT(x);
}