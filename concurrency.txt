一、简介
	线程的优势:
		1.发挥多处理器的强大功能
		2.建模简单
		3.异步事件的简化处理
		4.界面响应
	线程的风险
		1.安全性问题
			本质就是竞争问题。
		2.活跃性问题
			当某个需要执行的操作无法执行时，就引发活跃性问题。在串行程序中，死循环就是典型的活跃性问题。在并发中活跃性问题更常易发生，例如死锁。
		3.性能问题
			由活跃性问题引申出来的，活跃性问题解决了(需要执行的东西终会执行)，但是解决的不够好(等待太长)，那么就会带来大量的性能损失。
二、线程安全性
	线程安全的代码，核心在于要对【共享且可变】对象的状态访问操作进行管理。
	对象状态: 对象实例域或静态域的数据，这里面包括其他依赖对象的域。若将对象看做是多叉树，每个域是个节点，那么叶节点就是对象的状态。
	共享：意味着对象可以有多个线程同时访问。
	可变，意味着对象的值在生命周期类是可以改变的。（即对象改变）
	解决对象的线程问题，归结为3点:
		a).不在线程之间共享对象。
		b).将变量修改为不可变的。
		c).在访问对象方法时，使用同步。
	1.线程安全型
		一个类的线程安全性，是指它不过运行时采用何种调度，这些线程如何交替执行，在对象外的代码中不需要任何的同步或协同操作，这个类都将表现出【正确】行为，那么就是线程安全的。
		【正确】一词的解释是：满足人为规定的不变性条件 和 后验条件。
		更具体的说，不变性条件是认为逻辑上施加给类中状态的约束，比如类中有int min和int max两个变量，人为约束min是小于max的，不管对象的方法做了什么操作，都不应该违背这个约束。
		因此若有更新min和max的操作，一定要小心，因为若不做同步，很可能违背这个正确性，比如if(i<max){min=i}和if(j>min){max=j}，若min=0， max=5， i=5， j=3，这里若设置min=5前线程被切换到max=3后，由于3>min，因此会执行max=3，然后再切换回去执行min=5，这样不变形条件就错了。
	2.原子性问题
		原子性问题，是一个操作的最小单元。有两种常见需要压缩为原子操作的情形
		1).先检查后执行
			典型的例子是延迟初始化:
			public Object getInstance(){
				if(instance == null){
					instance = new Object();
				}
				return instance;
			}
			很明显，当instance==null进入if条件后，线程切换，次数instance还是null，而新的线程也进行这个判断，生成了新的object并且返回该object，此时反回到了原来的线程，此时会重新再new一个instance出来。
		2).读取-修改-写入
			如i++操作，就蕴含了读取值，修改值，写入值的3个操作。
		这些操作都是原子操作，在操作过程中，忌讳其他线程进行修改，因此需要用同步。
	3.加锁机制
		在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束， 因此当更新一个变量时，需要在同一个原子操作中对其他变量进行更新。
			* synchronized
				java提供了锁机制来支持原子性，首先需要了解到，每个对象中都有个锁计数器，用于支持锁机制。
					synchronized(object){
						....
					}
				当线程进入了该代码块，若对象的锁计数器为0，线程会获得object对象的锁，object的锁计数器会+1，并且记录锁的拥有者线程。当退出某个对象的同步代码块时，锁计数器减一。
				当线程进入了该代码块，若对象的锁计数器不为0，且拥有者线程为本线程，锁计数器会继续加1。这又被称为锁的重入。
				当线程进入了该代码块，若对象的锁计数器不为0，且拥有者不是本线程，那么阻塞，直到锁计数器为0。
				public synchronized void service(){
					...
				}
				等价于，即拿到本对象的锁
				public void service(){
					synchronized(this){
						...
					}
				}
				synchronized是个重量级的锁，尽量缩短其代码块范围。
三、对象的共享
	对象的共享，主要是了解如何共享和发布对象，从而是它们能够安全地由多个线程同时访问。
	1.可见性
		通常，我们无法确保执行读操作的线程能及时的看到其他线程写入的值。这是因为其他线程线程将值写入内存，而读操作内存有可能不是从内存里面直接读取的，而是编译器经过了优化从缓存里面读取，或者经过了重排序，而无法得到正确的值。这样的问题称为可见性问题。
		为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。在没有同步的情况下，编译器、处理器以及运行时都看对操作的执行顺序进行意想不到的调整。
		虽然没有同步，而可能造成失效值，但至少值是有一个初始值的，这种安全性是最低安全性的。但64bit数值变量的操作的读写操作都不是原子操作，而是2个32bit的操作。因此共享可变的long和double变量是不安全的，需要用同步或是volatile.
	2.volatile
		使用synchronized加锁，是可以让变量可见的，但是这样太重了，对于一般的变量可以用volatile声明。编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
		volatile也不会被缓存在寄存器或者其他处理器看不见的地方。volatile的变量其同步的可读性不够高(因为不用加同步代码块)，volatile可以用来确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及【标识】一些重要的显存声明周期事件的发生。主要还是标识用。
	3.发布与溢出
		发布一个对象，是指使对象 能够在当前作用域之外的代码中使用，比如一个私有对象通过get方法返回出去，这样就到了其他作用域了。当某个不应该发布的对象发布出去了，就成为逸出。
		当发布一个对象的时候，在该对象非私有域的所有对象同样会被发布，比如发布了一个map，map里面的所有kv都被发布出去了就。
		当一个对象逸出后，必须假设某个类或线程可能会误用该对象，这是肯定的，不能保证外面的代码会怎么对待这个对象。这就是使用封装的主要原因，避免逸出现象。
		* 安全的对象构造过程
			在构造过程中，如果使用内部类的技术，很有可能会造成this对象逸出。因为若在构造返回之前，就有什么别的原因，由其他线程触发了这个内部类中的方法调用，而此时由于构造函数还未完成，会造成不可预测的结果。
			因此安全的方法是将构造函数用private封装起来，由类的static函数进行构造，避免this在构造完成之前逸出。
			public class SafeListener{
				private final EventListener listener;
				private SafeListener{
					listener = new EventListener(){
						public void onEvent(Event e){
							do(e);
						}
					}
				};
				
				public static SafeListener newInstance(EventSource source){
					SafeListener safe = new SafeListener();
					source.registerListener(safe.listener);
					return safe;
				}
			}
	4.线程封闭
		将数据封闭到线程内部，就可以不用进行同步了，主要避免对象不小心从哪里逸出出去。
		1).ad-hoc线程封闭
			维护线程封闭性的职责由程序来承担，这种封闭非常脆弱，很少使用。
		2).栈封闭
			超简单，就是指建立局部变量，变量将由虚拟机栈维护。
		3).ThreadLocal类
			栈封闭终究有些不方便，要在单线程内使用一些全局的变量，就没办法了，必须要通过方法传参的方式，这终究有些不便，直接用全局变量又容易逸出，解决方法是用ThreadLocal类。
			这个类相当于是一个Map<ThreadId, Object>，里面保存了当前线程的全局变量，需要用到时则取出来，比如jdbc的connection，它的构造非常低效，因此创建一次就够了，后面需要反复使用，而又不能在哪里使用就在那里涉及的方法调用链中加参数，这样太麻烦了，就用ThreadLoca全局提供即可。
			ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>(){
				public Connection initialValue(){
					return DriverManager.getConnection(DB_URL);
				}
			};
			通过connectionHolder.get()，可以获得里面的值。
			当线程终止时，ThreadLocal对应线程里面的对象，全部都会清空。
	5.不可变对象
		之前的种种问题，都与状态【可变】相关，如果状态【不可变】那么也就没有这些问题了。如果某个对象在创建后状态就不能被修改，那么对象就成称为不可变对象。
		不可变对象，一定是线程安全的。但需要注意的是，【不可变对象】与【不可变对象的引用】两者是有区别的，保存在不可变对象中的状态虽然没法更新，但是引用可以更新，也就是创建新的不可变对象来更新。
		满足一下条件的对象才是不可变的:
			* 对象创建以后状态就不能修改
			* 对象的所有域都是final类型
			* 对象是正确创建的(构造期间，this引用没有溢出)
		由于是通过改变【不可变对象的引用】来更新状态的，引用是多个线程共享的，因此需要声明引用类型为volatile。
	6.安全发布
		1).安全发布的常用模式
			* 在静态初始化函数中初始化一个对象引用
			* 将对象的引用保存到volatile类型的域中
			* 将对象的引用保存到某个正确构造对象的final类型的域中
			* 将对象的引用保存到一个由锁保存的域中
		2).安全的共享对象
			* 线程封闭: 直接不用共享，就安全了。
			* 只读共享: 就是不可变对象或者事实不可变对象。
			* 线程安全共享: 线程安全的对象在其内部实现同步，可以由多个线程通过接口来访问而不需要进一步同步。
			* 保护对象