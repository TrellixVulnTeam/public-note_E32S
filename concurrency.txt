一、简介
	线程的优势:
		1.发挥多处理器的强大功能
		2.建模简单
		3.异步事件的简化处理
		4.界面响应
	线程的风险
		1.安全性问题
			本质就是竞争问题。
		2.活跃性问题
			当某个需要执行的操作无法执行时，就引发活跃性问题。在串行程序中，死循环就是典型的活跃性问题。在并发中活跃性问题更常易发生，例如死锁。
		3.性能问题
			由活跃性问题引申出来的，活跃性问题解决了(需要执行的东西终会执行)，但是解决的不够好(等待太长)，那么就会带来大量的性能损失。
二、线程安全性
	线程安全的代码，核心在于要对【共享且可变】对象的状态访问操作进行管理。
	对象状态: 对象实例域或静态域的数据，这里面包括其他依赖对象的域。若将对象看做是多叉树，每个域是个节点，那么叶节点就是对象的状态。
	共享：意味着对象可以有多个线程同时访问。
	可变，意味着对象的值在生命周期类是可以改变的。（即对象改变）
	解决对象的线程问题，归结为3点:
		a).不在线程之间共享对象。
		b).将变量修改为不可变的。
		c).在访问对象方法时，使用同步。
	1.线程安全型
		一个类的线程安全性，是指它不过运行时采用何种调度，这些线程如何交替执行，在对象外的代码中不需要任何的同步或协同操作，这个类都将表现出【正确】行为，那么就是线程安全的。
		【正确】一词的解释是：满足人为规定的不变性条件 和 后验条件。
		更具体的说，不变性条件是认为逻辑上施加给类中状态的约束，比如类中有int min和int max两个变量，人为约束min是小于max的，不管对象的方法做了什么操作，都不应该违背这个约束。
		因此若有更新min和max的操作，一定要小心，因为若不做同步，很可能违背这个正确性，比如if(i<max){min=i}和if(j>min){max=j}，若min=0， max=5， i=5， j=3，这里若设置min=5前线程被切换到max=3后，由于3>min，因此会执行max=3，然后再切换回去执行min=5，这样不变形条件就错了。
	2.原子性问题
		原子性问题，是一个操作的最小单元。有两种常见需要压缩为原子操作的情形
		1).先检查后执行
			典型的例子是延迟初始化:
			public Object getInstance(){
				if(instance == null){
					instance = new Object();
				}
				return instance;
			}
			很明显，当instance==null进入if条件后，线程切换，次数instance还是null，而新的线程也进行这个判断，生成了新的object并且返回该object，此时反回到了原来的线程，此时会重新再new一个instance出来。
		2).读取-修改-写入
			如i++操作，就蕴含了读取值，修改值，写入值的3个操作。
		这些操作都是原子操作，在操作过程中，忌讳其他线程进行修改，因此需要用同步。
	3.加锁机制
		在不变性条件涉及多个变量时，各个变量之间并不是彼此独立的，而是某个变量的值会对其他变量的值产生约束， 因此当更新一个变量时，需要在同一个原子操作中对其他变量进行更新。
			* synchronized
				java提供了锁机制来支持原子性，首先需要了解到，每个对象中都有个锁计数器，用于支持锁机制。
					synchronized(object){
						....
					}
				当线程进入了该代码块，若对象的锁计数器为0，线程会获得object对象的锁，object的锁计数器会+1，并且记录锁的拥有者线程。当退出某个对象的同步代码块时，锁计数器减一。
				当线程进入了该代码块，若对象的锁计数器不为0，且拥有者线程为本线程，锁计数器会继续加1。这又被称为锁的重入。
				当线程进入了该代码块，若对象的锁计数器不为0，且拥有者不是本线程，那么阻塞，直到锁计数器为0。
				public synchronized void service(){
					...
				}
				等价于，即拿到本对象的锁
				public void service(){
					synchronized(this){
						...
					}
				}
				synchronized是个重量级的锁，尽量缩短其代码块范围。