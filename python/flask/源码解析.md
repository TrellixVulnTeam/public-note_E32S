# 一、概述
flask基于werkzeug库的， werkzeug是一个

# 二、app.py
这个模块是WSGI处理的核心模块
## 1.*Flask类*
这个类继承于helper.py中的。这个类实现了WSGI应用，并充当中心处理对象。这个类的初始化参数需要传递模块名(__name__)，这个__name__用来在文件系统上查找资源。
### 1).__init__
```py
class Flask():
    request_class = Request
    response_class = Response
    jinja_environment = Environment
    app_ctx_globals_class = _AppCtxGlobals
    config_class = Config

    def __init__(
        self,
        import_name,
        static_url_path=None,
        static_folder='static',         # 静态文件夹默认为 static/, 这是相对于【root_path】而言的。
        static_host=None,
        host_matching=False,
        subdomain_matching=False,
        template_folder='templates',    # 模版文件夹默认为 templates/
        instance_path=None,             # 将会自动设置为__main__模块路径+/instance
        instance_relative_config=False,
        root_path=None                  # 默认将会设置为工作路径
    ):
        # 将模块名、模版文件夹、根路径放进行打包，不可再做修改
        _PackageBoundObject.__init__(self,
            import_name,
            template_folder=template_folder,
            root_path=root_path)        # 设置app的root_path，默认为工作路径

        # 设置模版文件夹
        if static_url_path is not None:
            self.static_url_path = static_url_path

        # 设置静态文件夹
        if static_folder is not None:
            self.static_folder = static_folder

        if instance_path is None:
            # 自动获取app实例路径，若没有设置，默认用模块名的路径(模块名若为__main__，则采用当前工作路径)+/instance
            instance_path = self.auto_find_instance_path()
        elif not os.path.isabs(instance_path):
            raise ValueError(
                'If an instance path is provided it must be absolute.'
                ' A relative path was given instead.'
            )
        self.instance_path = instance_path

        # 加载输入的配置文件
        self.config = self.make_config(instance_relative_config)

        # 用来保存试图函数(即controler路由, 默认将会配置static的controller路由个), 
        self.view_functions = {}
        self.error_handler_spec = {}
        self.url_build_error_handlers = []
        self.before_request_funcs = {}
        self.before_first_request_funcs = []
        self.after_request_funcs = {}
        self.teardown_request_funcs = {}
        self.teardown_appcontext_funcs = []
        self.url_value_preprocessors = {}
        self.url_default_functions = {}
        self.template_context_processors = {
            None: [_default_template_ctx_processor]
        }
        self.shell_context_processors = []
        self.blueprints = {}
        self._blueprint_order = []
        self.extensions = {}
        # 保存了匹配规则，用来进行细节的匹配。实际路由时，使用该变量。
        self.url_map = Map()
        self.url_map.host_matching = host_matching
        self.subdomain_matching = subdomain_matching

        # 为镜头文件添加处理匹配规则和处理函数
        if self.has_static_folder:
            assert bool(static_host) == host_matching, 'Invalid static_host/host_matching combination'
            self.add_url_rule(
                self.static_url_path + '/<path:filename>',
                endpoint='static',
                host=static_host,
                view_func=self.send_static_file
            )
        self.cli = cli.AppGroup(self.name)
```

## 2).对静态文件的处理
默认将会设置静态函数的路径为static, 这个路径时相对于【工作路径】而言的。访问静态文件将会调用默认的静态文件处理函数`send_static_file`。
```py
def send_static_file(self, filename):
        if not self.has_static_folder:
            raise RuntimeError('No static folder for this object')
        # Ensure get_send_file_max_age is called in all cases.
        # Here, we ensure get_send_file_max_age is called for Blueprints.
        cache_timeout = self.get_send_file_max_age(filename)
        # 从给定的目录self.static_folder中获取文件，并设置缓存超时时间，然后返回该文件内容。
        return send_from_directory(self.static_folder, filename,
                                   cache_timeout=cache_timeout)

# 获取文件的缓存过期时间
def get_send_file_max_age(self, filename):
    return total_seconds(current_app.send_file_max_age_default)

# 根据设定的缓存天和秒，换算为缓存的秒
def total_seconds(td):
    return td.days * 60 * 60 * 24 + td.seconds

# 返回指定文件
def send_from_directory(directory, filename, **options):
    filename = safe_join(directory, filename)
    # 判断是否为绝对路径
    if not os.path.isabs(filename):
        # 设置为绝对路径
        filename = os.path.join(current_app.root_path, filename)
    try:
        if not os.path.isfile(filename):
            raise NotFound()
    except (TypeError, ValueError):
        raise BadRequest()
    options.setdefault('conditional', True)
    return send_file(filename, **options)

# 实际发送文件的函数
def send_file(filename_or_fp, mimetype=None, as_attachment=False,
              attachment_filename=None, add_etags=True,
              cache_timeout=None, conditional=False, last_modified=None):
    # 太长，不列出。
    # 检查参数合法性
    # 设置请求头
    # 构造响应rv = current_app.response_class(data, mimetype=mimetype, headers=headers, direct_passthrough=True)
    # 获取文件内容
    # 文件内容放入rv
    # 返回rv
```