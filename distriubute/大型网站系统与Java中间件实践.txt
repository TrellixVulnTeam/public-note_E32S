一、分布式系统
	分布式系统的定义：
		# 组件分布在网络计算机上
		# 组件之间仅仅通过消息传递来通信并协调行动
	1.线程与进程的执行模式
		# 互不通信的多线程模式。线程之间独立，各自完成自己的工作。
		# 基于共享容器协同的多线程模式。通过生产者消费者，读写锁，独占锁等机制管理共享的容器。
		# 通过事件协同的多线程模式。其实就是事件队列。A线程执行过程中必要的时候wait，等待B线程的notify。
		# 多进程模式。分布式系统，本质上就是多进程模式。
	2.网络编程：
		BIO，NIO，AIO。
	3.单机的分布式化
		根据冯诺依曼结构，单机系统主要有5个部分，当要转为分布式系统时，这5个部分都需要进行改变：
			1).输入
				分布式系统每个节点的输入将会是 其他节点的输出 以及 传统人机交互设备的输入。
			2).输出
				分布式系统每个节点的输出将会是 其他节点的输入 以及 传统人机交互设备的输出。
			3).控制器
				控制器起着协调计算的作用，更进一步是获取输入指令并根据指令进行相关的运算得到结果。
				在分布式系统中控制器通常是:
					a).负载均衡器
						client ----> 负载均衡器 ----> 服务器节点
						负载均衡器由分硬件负载均衡和软件负载均衡，其中软件负载均衡又有四层负载均衡和七层负载均衡的区别。
						不管是哪种均衡方式，都是属于透明代理，即对于发送和处理请求的两端，都是透明的，两端相对独立。
						但是存在两个不足：
							# 会增加网络开销。原本两次通信可以解决的(请求和响应)，现在需要四次通信(请求到均衡器，均衡器到节点，节点响应均衡器，均衡器到客户端)
							# 如果代理出了问题，整个系统崩溃。因此需要作热备份，当时未完成的请求还是会受到影响。
						HTTP服务常用负载均衡器。
					b).命令服务/规则服务器
						client ----> 服务器节点
						   |              |
						  \|/             | 
					命名服务/规则服务器<--|
						对于命令服务器，是将node列表放在命名服务中，客户端若没有node列表则会到命名服务器进行查询，有node列表后自行判断到那个node进行请求。命名服务需要收集node信息。
						对于规则服务器，规则服务器会将如何选择node的规则发送给client，知道client选择规则。
					c).Master
						Master来管理工作的任务，并将任务的具体处理交给Worker来进行。
				也有一些分布式是去中心化的，比如Redis是没有中央的。
			4).运算器
				在分布式系统中，运算器就是各个处理节点。
			5).存储器
				存储器也是由多个节点组成，通常存在两种模式：
					a).代理服务器模式
						和负载均衡器模式类似，client先到代理服务器，代理服务器再到storage_node。
					b).名称服务模式
						client ---> storage_node
						   |             |
						  \|/            |
						名称服务<--------|
						该架构有两种具体的实现模式，名称服务采用规则服务器和Master两种：
							# 规则服务器
								storage_node的选择逻辑 和 storage_node列表 将从规则服务器中拉取到client上。
								client自行执行选择逻辑，找到应该使用的storage_node。需要注意的是，必须要确保该client的k若做了保存，后面是需要找得到的。
								这样就要求，若storage_node出现了故障或是新增，client如何获悉，规则服务器如何获悉，以及对于原始数据应该如何重新分配。
								需要采用 虚拟节点+一致性哈希。
							# Master
								storage_node的选择逻辑存在于Master，client每次都需要到Master进行查询当前的k对应到哪个storage_node上，然后client直接到该storage_node进行操作。
	4.分布式系统难点
		1).缺乏全局时钟
			同步本身就需要时差，无法做到完全同步。
			全局时钟是为了协同一些行为，通常需要一个单独的集群来区分多个动作的顺序。
		2).故障独立性
			即整个系统的一部分有问题而其他部分正常，即故障的独立性。
		3).处理单点故障
			若存在单点，则该处就是性能瓶颈，因为单点崩溃意味着该单点所连接的业务完全崩溃。
			因此需要对单点进行集群化，集群化后要解决故障独立性。
			若无法进行集群化，则需要进行备份，以便宕机恢复。也可以降低单点故障的影响范围，比如将一个表拆分到多个服务器上，当某个服务器崩溃后，其他服务器上的表还能正常。
		4).分布式一致性与事务
			通过两阶段提交，Paxos等协议进行。
二、大型网站的演进
	大型网站是一个模糊的概念，当 海量数据+高并发+业务复杂度 这三者都比较高时，就属于大型网站。
	现在假设这是一个交易网站，交易网站有三个最基本的功能：用户(用户注册，用户管理...)、商品(商品展示，商品管理，...)、交易(创建交易，交易管理，支付...)
	1.单机模型
		用户，商品，交易等业务所需要的基本代码以及数据库全部放在一个机器中。
		|-------------------|
		| 用户，商品，交易  |
		|  |-------------|  |
		|  |   DataBase  |  |
		|  |-------------|  |
		|-------------------|
		用户，商品，交易等基本功能通过JDBC和DataBase连接。
	2.单机负载警告，数据库与应用分离
		其实就是将DataBase拉出来，单独作为一个节点。用户缓解应用服务器的压力。两者的连接本来耦合就很低，很容易实现。
	3.应用服务器负载警告，应用服务器集群化
		由于是HTTP请求，且HTTP是无状态的，节点间的耦合性较低，容易进行独立。
		1).负载均衡方案
		2).共享Session方案
	4.数据库读负载警告，读写分离与缓存
		1).读写分离
		2).缓存
	5.引入分布式存储系统
	6.数据库拆分
		1).垂直拆分
		2).水平拆分
	7.应用拆分
	8.SOA
三、中间件