一、分布式系统
	分布式系统的定义：
		# 组件分布在网络计算机上
		# 组件之间仅仅通过消息传递来通信并协调行动
	1.线程与进程的执行模式
		# 互不通信的多线程模式。线程之间独立，各自完成自己的工作。
		# 基于共享容器协同的多线程模式。通过生产者消费者，读写锁，独占锁等机制管理共享的容器。
		# 通过事件协同的多线程模式。其实就是事件队列。A线程执行过程中必要的时候wait，等待B线程的notify。
		# 多进程模式。分布式系统，本质上就是多进程模式。
	2.网络编程：
		BIO，NIO，AIO。
	3.单机的分布式化
		根据冯诺依曼结构，单机系统主要有5个部分，当要转为分布式系统时，这5个部分都需要进行改变：
			1).输入
				分布式系统每个节点的输入将会是 其他节点的输出 以及 传统人机交互设备的输入。
			2).输出
				分布式系统每个节点的输出将会是 其他节点的输入 以及 传统人机交互设备的输出。
			3).控制器
				控制器起着协调计算的作用，更进一步是获取输入指令并根据指令进行相关的运算得到结果。
				在分布式系统中控制器通常是:
					a).负载均衡器
						client ----> 负载均衡器 ----> 服务器节点
						负载均衡器由分硬件负载均衡和软件负载均衡，其中软件负载均衡又有四层负载均衡和七层负载均衡的区别。
						不管是哪种均衡方式，都是属于透明代理，即对于发送和处理请求的两端，都是透明的，两端相对独立。
						但是存在两个不足：
							# 会增加网络开销。原本两次通信可以解决的(请求和响应)，现在需要四次通信(请求到均衡器，均衡器到节点，节点响应均衡器，均衡器到客户端)
							# 如果代理出了问题，整个系统崩溃。因此需要作热备份，当时未完成的请求还是会受到影响。
						HTTP服务常用负载均衡器。
					b).命令服务/规则服务器
						client ----> 服务器节点
						   |              |
						  \|/             | 
					命名服务/规则服务器<--|
						对于命令服务器，是将node列表放在命名服务中，客户端若没有node列表则会到命名服务器进行查询，有node列表后自行判断到那个node进行请求。命名服务需要收集node信息。
						对于规则服务器，规则服务器会将如何选择node的规则发送给client，知道client选择规则。
					c).Master
						Master来管理工作的任务，并将任务的具体处理交给Worker来进行。
				也有一些分布式是去中心化的，比如Redis是没有中央的。
			4).运算器
				在分布式系统中，运算器就是各个处理节点。
			5).存储器
				存储器也是由多个节点组成，通常存在两种模式：
					a).代理服务器模式
						和负载均衡器模式类似，client先到代理服务器，代理服务器再到storage_node。
					b).名称服务模式
						client ---> storage_node
						   |             |
						  \|/            |
						名称服务<--------|
						该架构有两种具体的实现模式，名称服务采用规则服务器和Master两种：
							# 规则服务器
								storage_node的选择逻辑 和 storage_node列表 将从规则服务器中拉取到client上。
								client自行执行选择逻辑，找到应该使用的storage_node。需要注意的是，必须要确保该client的k若做了保存，后面是需要找得到的。
								这样就要求，若storage_node出现了故障或是新增，client如何获悉，规则服务器如何获悉，以及对于原始数据应该如何重新分配。
								需要采用 虚拟节点+一致性哈希。
							# Master
								storage_node的选择逻辑存在于Master，client每次都需要到Master进行查询当前的k对应到哪个storage_node上，然后client直接到该storage_node进行操作。
	4.分布式系统难点
		1).缺乏全局时钟
			同步本身就需要时差，无法做到完全同步。
			全局时钟是为了协同一些行为，通常需要一个单独的集群来区分多个动作的顺序。
		2).故障独立性
			即整个系统的一部分有问题而其他部分正常，即故障的独立性。
		3).处理单点故障
			若存在单点，则该处就是性能瓶颈，因为单点崩溃意味着该单点所连接的业务完全崩溃。
			因此需要对单点进行集群化，集群化后要解决故障独立性。
			若无法进行集群化，则需要进行备份，以便宕机恢复。也可以降低单点故障的影响范围，比如将一个表拆分到多个服务器上，当某个服务器崩溃后，其他服务器上的表还能正常。
		4).分布式一致性与事务
			通过两阶段提交，Paxos等协议进行。
二、大型网站的演进
	大型网站是一个模糊的概念，当 海量数据+高并发+业务复杂度 这三者都比较高时，就属于大型网站。
	现在假设这是一个交易网站，交易网站有三个最基本的功能：用户(用户注册，用户管理...)、商品(商品展示，商品管理，...)、交易(创建交易，交易管理，支付...)
	1.单机模型
		用户，商品，交易等业务所需要的基本代码以及数据库全部放在一个机器中。
		|-------------------|
		| 用户，商品，交易  |
		|  |-------------|  |
		|  |   DataBase  |  |
		|  |-------------|  |
		|-------------------|
		用户，商品，交易等基本功能通过JDBC和DataBase连接。
	2.单机负载警告，数据库与应用分离
		其实就是将DataBase拉出来，单独作为一个节点。用户缓解应用服务器的压力。两者的连接本来耦合就很低，很容易实现。
	3.应用服务器负载警告，应用服务器集群化
		由于是HTTP请求，且HTTP是无状态的，节点间的耦合性较低，容易进行独立。
		1).负载均衡
			由于是HTTP服务器，所以通常采用反向负载均衡器。
		2).共享Session
			session是会话数据，会话数据通常保存在服务器中，也可以通过cookie保存在客户端中。
			另外一点，session的标识是session，是通过cookie保存在客户端中的，客户端的每次请求都会带上cookie。
			若浏览器禁掉了cookie功能，则可以通过url来传输sessionid。
			a).session sticky
				本质意义上是相同的sessionid，负载均衡器会将其交给固定的node来处理。存在的问题是:
					* node的宕机，数据丢失。
					* 负载均衡器要获取sessionid，需要在应用层层面解析数据，这比在第4层解析的代价要高。
					* 负载均衡器会变成有状态的节点，消耗的内存。
			b).session replication
				node之间同步session，使他们的session一致。存在的问题是：
					* 同步session会造成大量的网络开销。
					* session数据太耗内存。
				具有较少node的中小应用可以考虑采用该方案。
			c).session storage
				将session集中保存，比如通过redis保存。存在的问题是：
					* 集中存储Session的机器或者集群有问题，影响使用。
					* 读写Session引入网络操作。
			d).cookie based
				其实就是cookie。将会话数据通过cookie保存在客户端中。存在的问题是：
					* cookie长度受限。
					* 安全性。
					* 带宽消耗。主要是每次数据传输都带有cookie。
		大型网站一般采用session sticky和session storage
	4.数据库读负载警告，读写分离与缓存
		1).读写分离
			通过一个专门的读库来承载读的任务，主库主要承载写任务和事务。不过有个问题非常重要：
				* 数据复制，主要指如何保证主库读库的数据一致性。
			数据复制有异步，半异步和同步的方案，各存在缺点。
		2).缓存
			对于读数据，应用服务想到cache中读取，若存在则读取出来，否则到数据库中读取并保存到cache。
			对于写数据，应用服务直接写到cache中。
			对于过期，缓存数据应该设置一个过期时间。
	5.引入分布式存储系统
		可以用来替代主库
	6.数据库拆分
		1).垂直拆分
			将不同的业务表放到不同的数据库中。存在的问题主要是：
				* 事务操作。应该尽量避免事务操作。
		2).水平拆分
			将同一个表拆分到不同的数据库中。读写分离可以缓解读压力，水平拆分可以缓解数据量的压力 以及 数据更新压力。存在的问题主要是：
				* SQL路由问题。同一个表的数据分散在了多个node上，需要在进行sql时了解数据的存放位置。
				* 主键的自增和唯一性问题。
				* 读取数据量太大时的分页问题。
	7.应用拆分
		根据业务的特性，把应用拆开到不同的node上去。
		这些应用都是基于【用户】，【商品】，【交易】这三大功能的，这造成了这些node上有这些基本功能的代码，带来代码冗余。
		比如:交易前台  网站后台  论坛  等具体业务都需要 用户 商品 交易 三大基本功能。
		代码分散在各个应用节点上，代码重用不便。并且各自业务节点各自访问数据库，由于业务相当多，因此会有大量的数据库连接。
	8.SOA
		主要是将三大功能【用户】，【商品】，【交易】放到服务node上。
		不同的业务，通过【RPC】来使用服务，与数据库的连接也交给服务来处理。
		更进一步，这样便于管理服务的代码。
	9.中间件
		中间件提供了操作系统所提供服务之外的服务，让软件开发者方便地处理通信、输入和输出。
		主要有三种：
			# 远程过程调用中间件，其实就是RPC框架。服务化的基础，通过RPC框架来调用服务。
			# 消息中间件，不同应用服务的消息传递，解耦和异步。主要是一些订阅处理，也就是对一些事件的异步处理。
			# 数据库访问中间件，主要是解决数据库访问的共性问题。
三、服务框架
	其实就是SOA的实现框架和基础。SOA方案：
		应用A  应用B  应用C 应用D...
	----------------------------------
		   服务1  服务2  服务3...
	----------------------------------
	     数据库  缓存系统 搜索引擎...
	其本质，就是在应用层和数据层之间添加了服务层。
	1.客户端的设计与实现
		1).使用方式
			通常通过spring方式来创建一个和生成代理的bean，需要给该bean指明interfaceName，version，group等属性。
			然后通过该bean，生成一个interfaceName的动态代理，该代理用于管理和服务器节点的通信。
			spring:
				<bean id="calculator" class="org.vanadies.ServiceFramework.ConsumerBean">
					<property name="interfaceName" val="org.vandies.Calculator" />
					<property name="version" val="1.0.0" />
					<property name="group" val="Test" />
				</bean>
			java:
				ConsumerBean consumer = factory.get("calculator");
				Calculator calculator = consumer.generate();
				int result = calculator.add(1, 2);				// 动态代理，将处理请求发送给服务器。
		2).寻址与路由
			动态代理的通信没有采用HTTP，因此可以采用命名服务。
			a).寻址架构
				命名服务器对于客户端而言，能提供服务器node列表。客户端每次在发起请求到具体的node前，需要检查内存中是否有node列表，
				若客户端不存在node列表，则到命名服务上去拉取node列表。客户端有了列表以后，通过具体路由算法将请求发送到指定的node。
			b).路由方案
				路由应该进行请求隔离，也就是不同的接口与方法应该交给不同的node去完成。这是为了应对不同的接口方法具有不同的耗时。
				若一个node上有耗时长与耗时短的方法，那么最后再执行线程中将会被大量的长耗时线程阻塞，短耗时的线程不能充分运行。
				路由规则也由命名服务管理，客户端会拉去到node列表和路由规则，通过这个规则和列表，路由到具体的node上去。
			若规则和节点列表有变化，命名服务应该通知客户端，这其实就是客户端节点订阅命名服务。
		3).服务调用
			在架构上，有两个线程和两个队列。
			两个线程：请求线程 和 IO线程。请求线程用于发起请求，由主线程控制。IO线程 用于管理socket连接 发送数据给node。
			两个队列：请求队列 和 通信对象队列。这两个队列都是生产者消费者。发起请求就是往请求队里中添加请求，并且生成一个通信对象。
			IO线程从请求队列中拿到请求，并发起请求，拿到结果以后得到通信对象，该对象在请求线程中也有缓存，以此通知请求线程。
			a).oneway。该方式是发送请求后，不关注结果。
				本质上其实就是省略了通信对象，并不会通知请求线程。
			b).callback。该方式发送请求后，在请求处理完成时会通过通信对象回调。
			c).Future。该方式发送请求后，在请求处理完成时配置Future对象的结果。请求线程也有缓存Future的。
	2.服务器的设计与实现
		1).使用方式
			也是通过spring进行配置，主要是需要声明接口名。
		2).线程池隔离
			由于在客户端有可能没有做请求隔离，造成在同一个node上会执行耗时长和耗时短的方法，这是就需要在服务器端做一个线程池隔离。
			一个线程池就代表了一个接口的一个方法，node将请求进行解析，将对应的请求交给对应的线程池。
四、数据访问层
	1.拆分的困难
		当数据和访问的增多，数据库压力越来越大，这时候要对数据库进行拆分。
		# 垂直拆分，把一个数据库中不同的业务单元数据分到不同的数据库里面。存在以下几个问题：
			- 单机事务需要变为分布式事务。
			- Join联表查询不方便，因为两表可能在不同的数据库。主要是将数据库的Join操作分成多次数据库操作。
			- 外键受限。尽量不做外键。
		# 水平拆分，把一个业务单元的数据分到多个数据库中。其实就是把一个表的数据放到多个数据库中。存在以下几个问题：
			- 和垂直拆分一样的问题。
			- 自增ID受影响。通过一个专有的ID生成器集群实现。
			- 单表查询要跨库。
	2.分布式事务
		拆分后，为了保证ACID，原本的单机事务，需要变为分布式事务。
		1).分布式事务模型
			分布式事务模型主要是指的 DTP模型，其中有以下几个角色：
				- TM，事务管理器，负责协调和管理事务。提供给AP接口，并且管理RM。比如在TM上面可以实现两阶段提交，Paxos等一致性算法。
				- RM，资源管理器，是一个DBMS系统，或者消息服务器管理系统。
				- AP，引用程序，就是使用DTP的程序。
			DTP还有如下几个概念：
				- 事务，完整的工作单元，并且是ACID的。
				- 全局事务，一次性操作多个RM的事务，就是全局事务。或者说就是一个完整的事务，该事务需要由多个RM来进行协同操作。
				- 分支事务，在全局事务中，每个RM有自己独立的任务，这些任务就是分支事务。
				- 控制线程，用来表述一个工作线程，主要是关联AP，TM和RM三者的线程。
			AP与RM之间，传统的数据库处理方式。
			AP与TM之间，使用TX接口，用于对事务进行控制，主要是启动事务、提交事务和回滚事务。其实就是事务的控制接口。
			TM与RM之间，采用一致性算法 控制和协调RM。
		2).两阶段提交
			TM将一个事务分割成多个事务交给多个RM来进行。
			TM会在分割事务后，先对每个RM发起一个准备指令，但收到所有RM准备完成的响应后，才会给所有的RM发送commit指令。
			若在准备阶段，有的资源没有准备，则回滚所有资源。
		3).CAP/BASE
		4).Paxos
	3.查询合并问题
		查询数据，单机情况原本只需要在一个表上就可以得到结果，现在结果可能分在 不同的库和不同的表中。这时候，我们需要对查询数据进行合并。
		1).排序
			多个来源的数据进行排序以后，则在AP上进行多路的归并排序操作。
			若查询的数据没有未排序，则在AP上进行外部排序。
		2).求平均值
			求SUM，求COUNT，进行计算。
		4).非排序分页
			即直接进行分页，不做排序。方式分为同等步长分页 和 同等比例分页。
			同等步长分页，指的是每页的每个数据源的数据个数是相等的。
			同等比例分页，指的是每页的不同数据源的数据比例，和数据源的数据个数比例相等。
			请求每页的负载都是相同的。
		5).排序分页
			此类较为麻烦，需要把每个数据源的所有数据拉到以后进行判断。
	4.数据访问层
		有专门的节点作为数据访问层来方便应用层对数据的使用。
		1).对应用层提供的接口
			通常有三种接口：a).专有API，b).JDBC接口，c).ORM接口
		2).数据访问层处理流程
			a).SQL解析
				对解析的缓存可以提升解析速度。根据SQL得到被操作的表，根据参数及规则确定目标数据源连接。
			b).规则处理
				规则处理主要是指的选择什么库什么表。有两种方案：
					i).固定哈希
					ii).一致性哈希+虚拟节点
			3).SQL改写
			4).数据源选择
				虽然在规则处理时，已经确定了什么库什么表，但是一般会给库提供备库。根据SQL当前执行的特定，是否在事务中以及权重规则，计算得到这次SQL请求要访问的数据库。
			5).SQL执行
			6).结果集合并返回处理
	5.读写分离
		1).master-slave非对称的处理
			通常master主库拥有很强的处理和存储能力，花费也大。slave作为master的读库，如果选择和master相同的性能，则成本太高不划算。
			因此通常一个读库有多个普通的计算机组成。
			常用的架构：
				应用
				 |
				 |------->分库规则配置<----------|
				 |                               |
				\|/                             \|/
			   数据层------>消息系统------>数据同步服务器
			     |                               |
				 |_____________________          |
				 |      |      |      |          |
				\|/    \|/    \|/    \|/         |
			  master  slave  slave  slave<-------|
			    /|\    /|\    /|\    /|\         |
				 |______|______|______|__________|
			应用层：就是要使用数据的程序。
			消息系统：本质上就是消息中间件，接收数据层对数据的更新操作，通知数据同步服务器。
			数据同步服务器：接收到消息系统的消息，得知应用层修改了master，数据同步服务器会更加具体做什么修改而进行负载工作，保证一致性。
			分库规则配置：在读数据时让数据层知道该如何去读，并且在数据同步服务器更新分库时(比如新增slave或是减少slave)，会对分库规则进行配置，以通知数据层新的分库规则。
		2).数据平滑迁移
			对于无状态的引用，比如HTTP服务器，扩容和缩容直接增加节点即可。而对于数据库的扩容和缩容会涉及数据的迁移。
			数据迁移最麻烦的是在迁移的过程中又会有数据的变化，通常的方案是，在开始进行数据迁移的时候，记录增量的日志，在迁移结束，再对增量的变化进行处理。
五、消息中间件
六、软负载中兴与集中配置管理
七、构建大型网站的其他要素