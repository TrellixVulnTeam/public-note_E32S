一、基本数据结构
	1.动态字符串
		Redis采用简单动态字符串(Simple Dynamic String, 即SDS)的抽象类型，并将SDS用作Redis的默认字符串表示。
		1).定义
			struct sdshdr{
				int len;		// buf中已经使用的字节数量，注意len不包含'\0'结尾符。
				int free;		// 记录buf数组中未使用的直接的数量
				char buf[];		// 字节数组，用于保存字符串
			}
		2)优点
			- 常数复杂度获取字符串长度
			- 杜绝缓冲区溢出
			- 减少修改字符串长度时所需的内存重分配次数
			- 二进制安全
			- 兼容部分C字符串函数
	2.链表
		1).定义
			链表节点
			typedef struct listNode{
				struct listNode *prev;		// 前置节点
				struct listNode *next;		// 后置节点
				void * value;				// 节点值
			}listNode;
			链表
			typedef struct list{
				listNode *head;
				listNode *tail;
				unsigned long len;
				void *(*dup)(void *ptr);				// 节点值复制函数, 复制节点链表所保存的值。
				void (*free)(void *ptr);				// 节点值释放函数, 将节点链表的空间释放掉。
				int (*match)(void *ptr, void *key);		// 节点值比较函数, 比较链表积淀所保存的值和另一个输入的值是否相等。
			}list;
	3.字典
		1).定义
			- hash表
				typedef struct dictht{
					dictEntry **table;			// table[i]指第i个桶，每个桶中又是一个dictEntry指针，用于构建链表
					unsigned long size;			// 桶个数
					unsgined long sizemask;		// 用于计算索引值，值恒定为size-1
					unsgined long used;			// hash表中已有的kv对数量
				}dictht;
			
			- hash表节点
				typedef struct dictEntry{
					void *key;					// entry的键
					union{						// entry的值，值可以采用指针，或是uint64的整数，或是int64的整数
						void *val;
						uint64_t u64;
						int64_t s64;
					}v;
					dictEntry *next;			// 下一个entry
				}dictEntry;
			
			- 字典
				typedef struct dict{
					dictType *type;		// 类型特定函数
					void *privdata;		// 私有数据
					dicht ht[2];		// 两个hashtable，第二个是用于扩容的辅助空间。
					int rehashidx;		// 用于rehash，记录rehash目前的进度。
				}dict;
				type是指向的dictType提供了一系列的函数集合，不同的dictType实现不同的函数
			- 操作特定类型kv对的函数
				typedef struct dictType{
				}dictType;
		2).rehash
			当hash表保存的kv对太多或者太少时，程序需要对hash表的大小进行扩大和缩小。
			a).为字典ht[1]哈希表分配空间，如果是扩容操作那么ht[1].size>=ht[0].used*2，如果是收缩操作那么ht[1].size>=ht[0].used，这样尽量让他退化成数组，以便快速读写。
			b).将保存在ht[0]的所有kv对计算k在ht[1]上的桶数，并放到ht[1]上。
			c).释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]上新建
		3).渐进式rehash
			一次性完成rehash在hash表特别大的时候是不太合适的，因为此时rehash操作将非常的耗时，此时应该考虑渐进式rehash。
			即分多次，渐进式的完成rehash。
			a).在ht[1]分配空间
			b).dict中维护这rehashidx，并将值设置为0，表示rehash正式开始。
			c).在rehash期间，每次对字典执行添加，删除，查找或者更新操作的时候，程序除了执行指定操作外还会将rehashidx对应的桶上的所有节点放到ht[1]中，并且rehashidx++。
			d).ht[0]的所有kv对都放到ht[1]上后，把rehashidx=-1，代表rehahs结束，再将ht[1]设置为ht[0]。
	4.跳跃表
		跳表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点指针，从而达到快速访问的目的。
		跳表支持平均O(logN)、最坏O(N)复杂度的节点查找。大部分情况下效率媲美平衡树，并且实现简单。
		跳跃表在Redis中主要是作为有序集合的实现 以及 集群节点中用作内部数据结构。
		1).结构
			- 跳跃表结构
				header，指向跳跃表头结点
				tail，指向跳跃表尾节点
				level，记录目前跳跃表内，最大的节点层数(排除头结点)
				length，记录跳跃表的长度，即包含的节点数(排除头节点)
			- 跳跃表节点结构
				typedef struct zskiplistNode{
					// 每个层都有两个属性，前进指针和跨度。前进指针用访问节点后的其他节点，跨度是前进指针指向的节点和当前节点的距离。
					struct zskiplistLevel{					
						struct zskiplistNode *forward;
						unsigned int span;
					}level[];
				
					struct zskiplistNode *backward;		// 用于指向当前节点的前一个节点。
					double score;	// 按该参数进行排序。
					robj *obj;		// 节点所保存的对象。
				}zskiplistNode;
				* 节点的leve越多，访问其他节点的速度越快，level的span上大下小。每次创建一个节点时，level个数是随机生产的。
	5.整数集合
		集合较小，并且里面全是整数的时候可以采用该方案。
		1).定义
			typedef struct intset{
				uint32_t encoding;		// 编码方式，指定数组中的元素采用什么类型。取值为INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64。
				uint32_t length;		// 集合包含元素的数量。
				int8_t   contents[];	// 保存元素的数组，虽然这里的类型是int8_t，但实际的类型取决于encoding。并且是按【从小到大】保存数据。
			}intset;
		2).升级
			新来的数据过大，当前的数据编码不能容纳它。此时需要对数据编码进行升级。
			需要注意的是升级是来的数据太大或者太小，因此必定是在所有数据大，或是比所有数据小，因此在最左边或是最右边进行扩展即可。
		3).降级
			intset不支持降级操作，一旦升级后就一直保存升级后的状态，就算集合里面最大值并非需要高级的状态。
	6.压缩列表
		可以用于实现列表对象或是hash对象。用于节约内存而开发的。
		1).构成
			- 压缩列表的构成
				zlbytes 4字节 记录压缩列表占用的内存总字节数。
				zltail  4字节 压缩列表首地址到最后一个节点之间所间隔的字节数。
				zllen   2字节 记录了压缩列表包含的节点数量。
				entry1  不定  压缩列表节点
				...
				entryN  不定  压缩列表节点
				zlend   1字节 特殊值0xFF，用于标记压缩列表的末端。
			- 压缩列表节点的构成
				previous_entry_length, 
					记录压缩列表中前一个节点的长度，长度是1字节(小于255字节时)或者5字节(第一个字节恒为0xFE标识是5字节大小)。
					通过指向当前节点的指针 以及 该参数，可以定位到上一个节点的起始位置。
				encoding, 记录content属性所保存的数据的类型以及长度
				content，负责保存节点的值
		2).连锁更新
	7.对象
		Redis并没有直接使用底层数据结构，而是构建了五种对象，并且在应用层上使用的是这些对象。
		Redis实现了基于【引用计数】的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的空间将会被回收。
		Redis也利用引用计数实现了内存共享机制，通过让多个数据库共享同一个对象来节约内存。
		Redis的使用是kv形式的，k和v分别为一个对象。
		Redis的对象抽象如下：
		typedef struct redisObject{
			unsigned type:4;			// 类型,取值有:REDIS_STRING, REDIS_LIST, REDIS_HASH, REDIS_SET, REDIS_ZSET
			unsigned encoding:4;		// 编码,取值有:REDIS_ENCODING_INT(long整数), EMBSTR(embstr编码的sds), RAW(sds), HT, LINKEDLIST(双端链表), ZIPLIST, INTSET, SKIPLIST(跳跃表和字典)
			unsigned lru:22;			// 记录对象最后一次被命令程序访问的时间
			void *ptr;					// 指向底层实现数据结构的指针，具体的类型由encoding指定
		}robj;
		通过 TYPE <key> 可以看到<key>所对应value的type。
		通过 OBJECT ENCODING <key> 可以看到<key>所对应value的encoding。
		1).字符串对象
			字符串对象的编码可以是int，raw，embstr。
			- int
				当一个字符串对象保存的是整数值，并且整数值可以用long来表示，那么ptr属性(此时为long *)里面就会保存该整数值。
				通过append向里面追加一个非数字的字符时，会被转换为raw。
			- raw
				当一个字符串对象保存的是一个字符串，并且该字符串长度大于32字节，那么使用sds来保存这个字符串。
			- embstr
				如果字符串长度<=32字节，采用embstr。和raw的区别在于：
					raw的内存申请和内存释放都是两次(因为有redisObject和sds两个对象)，embstr一次性分配连续的空间给redisObject和sds。
					连续空间能更好的使用缓存带来的优势。
				embstr是只读的，若通过append等函数修改，则会转换为raw格式。
			需要注意的是，浮点数实际保存也是当做字符串的，即把浮点数转换成字符串来保存。执行运算操作时会把字符串转换成浮点数再运行。
			String类型的redisObject，将会被其他4种对象复用，其他四种对象里面保存的元素其实就是type=string的redisObject(raw和embstr的选择仍然根据上述判断)。
		2).列表对象
			编码方式可以是ziplist，linkedlist。
			当同时满足以下两个条件时，列表对象使用ziplist编码，否则使用linkedList:
				* 列表对象保存的所有字符串元素的长度都小于64字节。
				* 列表对象保存的元素数量小于512个。
		3).hash对象
			编码方式可以是ziplist, hashtable.
			当同时满足以下两个条件时，hash对象采用ziplist编码，否则使用hashtable：
				* hash对象保存的所有kv对的字符串长度都小于64字节。
				* kv对象的个数小于512个。
			- ziplist
				一个kv对象在ziplist中总是紧挨着的，k在前，v在后。
				新添加的kv对将放在最后。
			- hashtable
				用dict保存kv对。
		4).集合对象
			编码方式可以是intset，hashtable。
			当同时满足以下两个条件时，使用intset编码，否则使用hashtable：
				- 集合对象保存的所有元素都是整数值。
				- 集合中的元素个数不超过512。
			在用hashtable是，采用的策略是在dict中key放集合元素，value放null。
		5).有序集合对象
			编码方式可以使ziplist，skiplist。
			zset <key> <score> <member>  在<key>这个有序集合中，添加一个分值为<score>的成员<member>
			- ziplist
				在使用ziplist时，每个集合元素使用两个紧挨的节点来保存，第一个节点是member，第二个节点是score，即member在前，score在后。
				score较小的放在靠近表头的方向，较大的靠近表尾。
			- skiplist
				跳跃表的object属性保存了元素的member，score元素保存了元素的score。
				并且有一个dict保存了从成员->分值映射，可以O(1)找到给定成员的分值。这样方便在跳跃表中通过成员来定位其位置。
			当同时满足以下两个条件时，对象使用ziplist，否则使用skiplist：
				* 有序集合所有成员的的字符串长度小于64。
				* 有序集合的元素数量小于128。
		6).引用计数
			- 内存自动回收
			- 复用节约内存
二、单机数据库的实现
	1.数据库
		Redis服务器将所有数据库都保存在redisServer结构的db数组中。	
		struct redisServer{
			int dbnum;			// 服务器数据库数量	, 由服务器配置的database选项决定，默认为16。
			redisDb **db;		// 
			struct saveparam *saveparams;		// 记录自动RDB条件的数组
			long long dirty;					// 上一次成功执行保存以后，服务器对数据修改的次数
			time_t lastsave;					// 上一次成功执行保存的时间
			sds aof_buf;						// aof缓冲区
		};
		1).切换数据库
			每个Redis客户端都会有目标数据库，客户端的读写操作都是在目标客户端中进行的。Redis客户端默认的目标数据库是0号数据库。
			可以通过SELECT指令来切换目标数据库。并且服务器内部，通过redisClient来维护客户端当前的状态，该状态中包含了客户端所用的目标数据库。
			typedef struct redisClient{
				redisDB *db;
			}redisClient{};
			SELECT指令就是修改这个属性。
		2).数据库键空间
			每个数据库都包含了一个hash结构，数据库中包含了很多的kv对。k是字符串的redisObject，v是有5种可能的redisObject。
			typedef struct redisDB{
				dict *dict;
				dict *expires;						// 过期字典。记录带过期时间的key
			}redisDB;
			在读取一个key后，会更新这个key里面的lru时间。
			若在读取一个key时，发现这个key过期了将会删除这个key。
			当有某个key被watch后，该key会被标记为脏，修改一次脏计数加1，这个计数会触发服务器的持久化以及复制操作。
		3).key的生存时间和过期时间
			EXPIRE 可以以秒为精度来设置某个key的生存时间(TTL)，在经过指定的时间之后就会自动删除生存时间为0的键盘。
			TTL 可以返回一个带有生存时间的key 剩余的生存时间。
			PERESIT 可以移除一个key的生存时间。
			- 保存过期时间
				redisDB中的expires属性保存了数据库中所有key的过期时间。所以expires被称为过期字典。
				expires的key指向某个数据库键，value是一个long long类型的整数，是一个unix时间戳。
			- 计算剩余生存时间
				过期时间戳-当前时间戳 即为 剩余生存时间。
			- 过期键的判断
				首先 检查键是否存在过期时间，如果存在，那么取得过期时间。
				最后 检查当前时间戳是否大于过期时间戳，大于那么过期，否则没有过期。
		4).过期键的删除策略
			a).通用策略
				- 定时删除
					行为：在设置key的过期时间的同时，创建一个timer，timer在key的过期时间到达时立即执行对key的删除操作。
					优点：过期及时删除，保证内存最优。
					缺点：当有多个键过期时，将会在删除上花费大量的cpu时间，使对高并发的请求响应过慢。而其实现在内存够用，根本不用删除进行释放内存。
				- 惰性删除
					行为：放任key过期不管，但是每次从dict取值时，都判断key是否过期，若过期则删除，没有过期则返回。
					优点：CPU时间最优，只有在必要的时候才会删除键。
					缺点：过期键太多，而这些键根本不可用，这属于一种内存泄露的行为。浪费大量的内存。
				- 定期删除
					行为：每隔一段时间，程序对过期字典进行检查，删除过期键盘。
					优点：通过一段时间的进行清理，优化了cpu时间和内存占用。
					缺点：定期时间如果隔得太短，清理时间太长，影响并发性。定期时间太长，清理时间太短，内存浪费现象仍然存在。不好取舍。
			b).redis策略
				redis的删除策略是惰性删除和定期删除相互配合的方式，在合理使用CPU时间和避免内存浪费之间取得了平衡。
				- 惰性删除的实现
				- 定期删除的实现
					Redis服务器周期性的操作serverCron时，activeExpireCycle就会被调用，在规定时间内分多次遍历服务器中的各个数据库
					随机抽出数据库中expires一部分键的过期时间，并删除其中的过期键。
				对其他功能的影响：
					* RDB
						在执行SAVE或者BGSAVE生成一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会保存到RDB中。
						在载入一个RDB文件时，对键的过期时间进行检查，没有过期的键会直接导入数据库中。若服务器是从服务器模式，载入时会载入过期键，但是在于主服务器同步时，从服务器会清空。
					* AOF
						过期键被定期或惰性删除以后，会向AOF追加一条DEL命令来显示的记录该键被删除。
						AOF重写时，会检查键是否过期，过期了的不会再保留。
					* 复制
						当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制：
							# 主服务器在删除一个键后，会显示地向所有从服务器发送一条DEL命令，告诉从服务器删除这个键。
							# 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会删除，而是返回该键值，相当于没有过期。
							# 从服务器只接受主服务器DEL来进行删除，这样是为了保证一致性。
	2.RDB(Redis Data Base)
		Redis的数据库状态是保存在内存中的，为了避免宕机等问题造成内存清空而数据消失，因此可以采用RDB持久化。RDB是压缩后的二进制文件。
		1).RDB的创建与载入
			SAVE 等待直到RDB文件创建完毕。
			BGSAVE 派生子进程，并由子进程创建RDB文件。
			Redis会在启动时检测RDB文件是否存在，若存在自动载入RDB文件，并且在载入期间服务器会处于阻塞状态。
			在BGSAVE期间，不能再接收SAVE和BGSAVE指令，并且BGREWRITEAOF会阻塞到BGSAVE完成以后去处理。
			需要注意的是，BGSAVE期间是创建的子进程，而子进程有父进程的所有数据，因此生成的文件是在开始进行异步RDB瞬间的快照。
		2).自动间隔性保存
			可以配置多个自动保存的时间条件，当满足其中一个自动保存的条件，那么会自动执行BGSAVE。
			save <second> <cnt> 指的是在<second>秒内修改了<cnt>次，则执行BGSAVE。
			该指令每执行一次，就设置一次自动保存条件。
			struct saveparam{
				time_t seconds;
				int changes;
			}
			Redis周期性操作函数serverCron默认每100ms会执行一次，该函数对于正在运行的服务器进行维护，
			其中一项工作就是检查save所选的保存条件是否满足，若满足则执行BGSAVE。
		3).不安全性
			要满足条件 或是 人为输入SAVE GBSAVE才进行同步，因此宕机容易丢失数据。
	3.AOF(Append Only File)
		aof通过保存Redis服务器执行的写命令来记录数据库状态。
		1).AOF持久化的实现
			当打开AOF后，服务器执行完一个写命令后，会以协议格式将被执行的写命令追加到aof_buf【缓冲区】的末尾。
			需要注意的是，添加到的是缓冲区而非硬盘，添加到硬盘是aof_buf里面的数据同步到硬盘。所以是完成了写命令，过段时间再进行持久化。
			Redis的服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及发送回复，时间事件负责执行serverCron这类函数。
			Redis服务器每次结束一个循环之前，都会调用flushAppendOnlyFile函数，用于判断是否需要将aof_buf中的数据同步到AOF文件中。
			是否进行同步，主要是通过appendfsync选项来进行判断：
				- always，将aof_buf缓冲区的内容全部写入并同步到AOF文件。最慢，也最安全。
				- everysec，将aof_buf缓冲区的内容全部写入，1秒同步一次。因为1秒才进行同步，所以顶多丢失1秒的数据。
				- no，将aof_buf缓冲区的内容全部写入，但是不进行同步。最快，但是容易丢失数据。
			写入指定是写入文件，但操作系统会先把数据放在缓冲区里面，直到缓冲区填满才同步到磁盘中。
		2).AOF的载入与还原
			只要Redis服务器读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态了。
			主要的步骤是：
				- 服务器创建伪客户端，这是因为Redis命令只能在客户端中执行，而AOF里面就是这些需要在客户端上执行的命令
				- 伪客户端读取并分析一条写命令
				- 使用伪客户端执行写命令，直至写完
		3).AOF的重写
			避免AOF文件过大，需要对其进行重写，压缩冗余命令。创建一个新的AOF文件代替旧的AOF文件。
			AOF重写也是一个耗时的工作，因此通常交于后台子进程完成。
			子进程是完全复制的父进程，也因此子进程有父进程数据的【完整副本】，保证了线程安全性。
			AOF重写期间，服务器可以继续接收写指令，会导致数据库状态和重写后的AOF文件所保存的状态不完全一致。
			为了解决不一致的问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建出子进程后开始使用，新的指令追加到该缓冲区中。
			AOF重写完成，将这些追加到AOF文件末尾。这个地方会造成阻塞。
		4).不安全性
			首先aof文件在指令执行后并不会立即同步，同步前如果宕机会丢失数据。
			其次aof重写时，此时新的写操作不会追加到原aof文件中，而是保存在内存中，在整个过程合并完成前宕机会导致数据丢失。
	4.事件
		Redis服务器是一个事件驱动的程序，服务器需要处理以下两个事件：
		1).文件事件
			Redis服务器通过socket与客户端连接，而文件事件就是对socket操作的抽象。通信会产生文件事件。
			Redis基于Reactor模式开发了网络事件处理器，也称为文件事件处理器：
				- 处理器使用IO多路复用程序来监听多个套接字，根据套接字当前执行的任务来为套接字关联不同的事件处理器，这个事件处理器其实就是函数。
				- socket准备好执行accept，read，write，close时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
			文件事件的处理器：
				- 连接应答处理
					当Redis服务器进行初始化的时候，会将监听socket和连接应答处理器绑定在一起，当有连接到来时引发连接应答处理器来执行。
				- 命令请求处理器
					该处理器负责从socket中读出客户端发出的命令请求。
				- 命令恢复处理器
					当服务器由命令回复需要传送给客户端时，会将写事件和命令恢复处理器绑定在一起，当客户端准备好接受数据，就会产生写事件，引发执行。
					写完成以后，解除命令回复处理器与写事件的绑定。
		2).时间事件
			有些事件在给定时间点执行，时间事件就是服务器对这类事件的抽象。
			时间事件分为两类：
				- 定时事件，让一段程序在指定的时间之后执行一次。
				- 周期事件，让一段程序每隔指定时间就执行一次。
			一个时间事件主要由以下三个属性组成：
				- id，全局唯一，从小打到递增。
				- when，记录时间事件的到达时间。
				- timeProc，时间事件处理器，其实就是个函数。当时间事件到达，服务器就会调用相应的处理器来处理事件。
			timeProc的返回值决定事件的类型，若返回AE_NOMORE，则为定时事件，否则为周期事件。若为周期事件返回的是一个时间，对这个时间事件进行更新，以便循环。
			服务器将所有的事件都放在一个【无序】链表中，每当时间事件处理器运行时就遍历整个链表，查找所有已到达时间的事件，并调用相应的事件处理器。
			上述无序，指的是不按when来进行排序，链表顺序是id从大到小。
			虽然是遍历，但是Redis通常【只有一个】serverCron时间事件，所以基本上是退化成了一个单链表来使用。
			serverCron时间事件
				- 清理过期键
				- 尝试AOF和RDB持久化操作
				- 若是主服务器，对从服务器进行定期同步
				- 若是处于集群模式，对集群进行定期同步和连接测试
				- 更新服务器的各类统计信息。
		3).事件的调度
			void processEvent(){
				time_event = asSearchNearestTimer();				// 获取最近的一个时间事件
				remaind_ms = time_event.when - unix_ts_nown();		// 计算还有多久执行最近的时间事件
				if(remaind_ms<0){remaind_ms=0;}
				timeval = create_timeval_with_ms(remaind_ms);		// 创建timeval结构
				aeApiPoll(timeval);									// 以timeval的超时时间来等待文件事件
				processFileEvents();								// 处理文件事件
				processTimeEvents();								// 处理时间事件
			}
			
			void main(){
				init_server();
				while(server_is_not_shutdown){						// 一直循环处理，在里面的remaind_ms上面会进行一定时间的阻塞，serverCron通常为100ms。
					processEvent();
				}
				clean_server();
			}