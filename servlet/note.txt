零、路径写法
1.超链接
	<a href="/webappName/doSome"></a>
2.form表单的action
	<form action="/webappName/doSome"></form>
3.web.xml的url-pattern
	<url-pattern>/doSome</url-pattern>
4.application.getRealPath
	String realPath = application.getRealPath("/doSome");
5.Welcome-file-list
	
也就三类:
	1).以/开始，加webappName名称
	2).以/开始，不加webbappName名称
	欢迎界面比较特殊，不加/
	
一、系统架构分类
C/S : Client / Server
B/S : Browser / Server. B/S是特殊的C/S，是C被限制为浏览器的C/S。

二、特点
B/S 优点：
		不需要安装特点的客户端软件，只需要浏览器就行了。
		升级只需要升级服务器端。
	缺点：
		所有数据全部集成在服务器端，数据丢失严重，相对来说不安全。
		速度慢。
		B/S的浏览器中界面粗糙。
C/S 优点：
		速度快。
		相对安全。
		ui漂亮。
	缺点：
		升级每一个客户端都需要升级。
		需要安装特点的客户端软件，才能访问服务器。

三、java web过程
浏览器访问http://host:8080/xxxx，访问到主机的Tomcat进程。并在Tomcat的webapps去寻找xxxx资源。
每个Tomcat都有一个webapps文件夹，该文件夹中保存了该Tomcat的所有引用。uri的后缀的/表示的根目录就是指的webapps。
对于资源的访问，有两种：
	静态资源：是在Tomcat中的已经有的html资源。Tomcat会直接范围该html。
	动态资源：是在Tomcat中的java程序。服务器将会运行这段程序，程序根据服务器逻辑得到需要返回浏览器的数据。

webapp和web服务器之间遵守的规范，就是servlet。因此servlet是一系列的接口，由web服务器调用，服务器通过这个接口，得到需要的数据，或者给与java程序数据。
javaweb的开发，就是实现servlet的接口，web服务器是servlet的调用者。

浏览器 ---http--> web server ---servlet---> 服务端java程序 ---jdbc---> 数据库

四、tomcat
启动：tomcat是纯java代码，因此tomcat需要运行在安装了java的机器上才能启动。启动tomcat要求已经指定了JAVA_HOME(jdk路径)
关闭：不可以强行关闭，否则8080端口可能会关闭失败。需要执行shutdown.bat

目录结构:
	/bin/ : 相关的命令，包括服务的启动和关闭。
	/conf/: 一些配置文件，比如端口号。使用.xml和.properties的文件。
	/lib/ : tomcat的各种jar包，里面有servlet的jar包....。
	/logs/: tomcat的日志信息，里面记录了错误的原因。
	/temp/: 临时文件，不须关心。
	/webapps/: 开发的app都是放在这个下面，是浏览器访问tomcat服务器时候的根路径。
	/work/: 和jsp相关。

五、注意
为了更加统一，url中的ip地址，端口号可以省略。但是网络资源路径必须是绝对路径。
servlet的开发的目录要求：
	/WEB-INFO/classes/			放字节码class
			 /lib/				放项目自己的jar包
			 /web.xml			请求路径的绑定
			 
六、生命周期
声明周期表示一个java对象从最初被创建到最终被销毁，经历了所有的过程。
servlet的生命周期，由web容器(如tomcat)管理，程序员无权干涉。
servlet对象从最初的创建开始，方法的调用，以及最后的servlet对象的销毁，整个过程是由web容器管理。
默认情况下，servlet对象在web服务器启动阶段不会被实例化。可以通过在web.xml中的<load-on-startup>标签中，配置启动服务器时，启动。其中的自然数是优先级，越小优先级越高。
当外部有浏览器第一次请求servlet的服务时，会初始化servlet对象，然后再调用init，最后调用service，该对象将会一直存在，知道tomcat服务器停止调用destroy方法，对象死亡。
整个生命周期的描述=>
	1). 用户在浏览器上输入url。
	2). web容器截取请求路径。
	3). web容器在容器上下文中，找请求路径对应的servlet对象。
	4). 若没有找到servlet对象(也就是说，之前没有实例化的servlet)
		4.1). 通过web.xml文件中的相关配置信息，得到请求路径对应的servlet完整类名。
		4.2). 通过反射机制，调用servlet类的无参数构造方法完成servlet对象的实例化。
		4.3). web调用servlet的init方法完成初始化操作
	5). tomcat拿到servlet对象，调用其service方法提供访问。
	6). web容器关闭时，或该servlet对象长时间没有用户访问时，web容器会将该servlet对象销毁。在销毁对象之前，web容器会调用servlet的destroy方法。
总结=>
	1.servlet类的构造方法只执行一次
	2.servlet对象的init方法只执行一次
	3.servlet对象的service方法，用户请求一次 执行一次。
	4.servlet对象的destroy方法只执行一次。

servlet对象的保存：
	大多数的web容器，都是将servlet对象以及对应的url-pattern存储到Map集合中。
	也就是说，在web容器中，有这样一个Map集合:
	Map<String, Servlet> 集合
	key			value
	----------------------------------
	/prj/login		LoginServlet对象的应用
	....

服务器在启动的时候，就会解析各个webapp的web.xml文件。这里也会保存一个Map集合：
	Map<String, String>
	将url-pattern和类名进行对应。
	
servlet接口中的所有方法解析：
1).无参数构造方法----|	 不建议使用构造函数，因为存在风险。程序员可能会创建一个有参数构造方法，造成无法提供无参构造函数，以致无法反射。
2).init方法--------------这两个方法执行时间几乎相同，执行次数都是一次，构造方法对象正在创建，init方法对象以及创建。
3).service方法, 完成业务逻辑的处理。
4).destroy方法, 用于释放资源等。
5).getServletConfig方法，用于之类获得servletConfig，得自己编写如何返回。
6).其他方法不用关注。

七、ServletConfig
ServletConfig，就是web.xml中的servlet标签找的配置信息....
serverConfig方法：
	- String getInitParameter(String name);	获取初始化参数的值。
	- Enumeration getInitParameterNames();	获得所有初始化参数的名字。
	- String getServletName();	获取<servlet-name>NAME</servlet-name>。
	- ServletContext getServletContext();	获取ServletContext【Servlet上下文】。
	注意，初始化参数的编写格式是：
	<init-param>
  		<param-name>NAME</param-name>
  		<param-value>VALUE</param-value>
  	</init-param>
	
八、ServletContext
一个webapp只有一个ServletContext对象，因为一个webapp只有一个web.xml。
=>ServletContext其实就是web.xml文件(整个web.xml)的结构化数据。
--->ServletContext在服务器启动时候的被实例化（因为web.xml在启动时被解析），在服务器关闭的时候被销毁。
因此ServletContext用于一个webapp中的所有servlet对象进行共享。相当于ServletContext是多线程共享的对象，因此修改时会存在安全问题。
----常用方法:
	Object getAttribute(String name);				从ServletContext范围中获取数据
	void setAttribute(String name, Object object);	向ServletContext范围中添加数据
	void remove Attribyte(String name);				移除ServletContext范围中的数据
	
	String getInitParameter(String name);
	Enumeration getInitParameterNames();
	
	String getRealPath(String path);				用于获取项目中文件的绝对路径的。

九、欢迎界面
默认是使用WebRoot文件下的index.html。（因为在tocat的conf文件夹中的web.xml中配置了它为欢迎界面）
若要自定义，那么在web.xml中，设置欢迎界面。
<welcome-file-list>
	<welcome-file>login.html</welcome-file>
	<welcome-file>...</welcome-file>
	...
</welcome-file-list>
这样在访问项目的时候，不用写完uri。
只需要访问http://xxxx/webappName就可以访问http://xxxx/webappName/login.html
这样访问更方便，可以提高用户体验。
可以设置多个欢迎界面，欢迎界面在<welcome-file-list>中从上往下找，若找到了，就返回该页。
欢迎界面可以上servlet。
注意，路径不用'/'开始

十、Http常见的错误代码(Http状态码)
404 : Not Found、资源未找到，请求的资源写错了。
500 : Server Inner Error、服务器内部错误, 一般是java程序异常
<error-page>
	<error-code>ERROR CODE</error-code>
	<location>/error/error.html</location>
</error-page>

配置错误代码所进行的页面显示。

十一、HTTP协议
超文本传输协议，浏览器和服务器之间的一种通讯协议，由W3C负责制定。
包括一下两种：
	1).请求协议
		a).请求行：
			用来发起一个http协议的请求。
			<请求方式> <URI> <请求方式>
		b).消息报头
		c).空白行
			用来分离消息报头和请求体的。
		d).请求体
			post传输时数据的位置
	2).响应协议
		a).状态行
			<协议版本号> <状态号> <状态描述信息>
		b).响应报头
			其中的Content-Type: text/html;charset-UTF8是告诉浏览器以UTF8显示，否则浏览器会用默认的编解码方式，可能造成乱码。
		c).空白行
			分离了响应报头与响应体。
		d).响应体
			也就是html内容。
GET和POST的区别:
	只有在form中，action使用post时，浏览器才会发送get请求。
	GET请求：
		在请求行提交数据，格式uri?name=value&...
		这种提交方式最终提交的数据会显示在浏览器的地址栏上。
		提交长度有限制。
		GET请求只能提交字符串，文件上传等等不可用GET。
		GET请求最终的结果，会被浏览器缓存收纳。下次访问，大量的数据不会加载。因为有大量的图片等等，不需要重新加载。
		GET常用在向服务器拿东西。也因此可以缓存。
		浏览器将资源缓存之后，是和某个特定的路径绑定在一起。只要浏览器发送相同的请求路径，会去缓存中获取资源，以这种方式降低服务器压力。但有时不需要用缓存，而是用服务器。在请求路径后面添加一个时间戳即可，这样GET请求也会得到新网页的。
	POST请求：
		提交格式name=value&...，在请求的请求体中，也就是跟在空白行后面。
		这个请求不会显示地址栏上。相对安全（其实也不是很安全）。
		提交长度无限制。
		提交内容无限制。
		POST请求响应后的结果不会被缓存。下次访问，会重新加载。
		POST常用在向服务器发送，或者修改东西。也因此，最好重新加载。
		post时，cache-control通常为no-cache或者是max-age=0，其实都是指的不用缓存。