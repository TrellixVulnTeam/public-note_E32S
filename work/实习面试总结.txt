一、java se
	1.反序列化的类名
		序列化的时候，会将对象的类信息放在序列化的字节中，方便在反序列化时加载相关相关的类。
	2.HashMap
		a).初始的大小
		b).是否线程安全
		c).读操作是线程安全的吗
	3.TreeMap
		a).为什么要用红黑树
	4.ArrayList
	5.LinkedList
二、java ee
	1.DispatchServlet流程
		a).通过请求从handlermapping中获取对应的控制器和拦截器链，mappedHandler = getHandler(processedRequest);
		b).使用handlerAdapter封装控制器，HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
		c).拦截器链处理，mappedHandler.applyPreHandle(processedRequest, response)
		d).执行控制器，得到mv。mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
		e).拦截器处理，applyPostHandle。
		f).主要是对结果mv进行处理，渲染视图。processDispatchResult。
	2.spring aop
	3.SpringMVC和Struts2的区别
三、oop
	1.面向对象设计的solid原则
		1).单一责任原则(Single responsibility)
			一个类的职责为一个，也只有这个原因会造成类的修改。当类需要承担其他责任时，应该分解该类。
		2).开闭原则(Open close)
			类应该是对扩展开放，对修改封闭的。
		3).里式替换原则(Liskov Substitution)
			子类和父类是is-A关系。
		4).接口分离原则(Interface Segregation)
			面向接口编程。
		5).依赖倒置原则(Dependency Inversion)
			高层模块不应该依赖于底层模块，二者都应该依赖与抽象。
			抽象不应该依赖细节，细节需要依赖抽象。
	2.哪些框架里面用过装饰器模式
		Stream
	3.哪些框架里面用过工厂模式(包括抽象工厂和工厂方法)？
		Spring(抽象工厂)、线程池，数据库连接池。
	4.为什么要使用工厂模式
四、jvm
	1.新生代gc的原理(Minor GC)
		新生代gc采用复制-清除算法。jvm给新生代分配了3块空间:survivor1, survivor2, Eden.
		新生对象放置在Eden空间中，当Eden满时将会把Eden和survivor中幸存的对象复制到另一个survivor中，然后将Eden清空。每次经过一次Minor GC将会使仍然幸存的对象年龄加一，达到一定年龄的对象将会转到老年代空间。
	2.full gc的触发时机和原理
		a).System.gc();建议jvm进行full gc，但是并不是立即执行。
		b).当Minor GC发生时，将会保存仍然幸存的对象，当仍然幸存的对象过大时，会向老年代空间申请空间，若老年代空间不够用了，会触发full gc。若仍然不够，则抛出异常。
		c).分配大对象时，会将大对象直接保存到老年代中，若老年代空间不够，会触发一次full gc。
	3.类加载流程
		1).加载，读取class的二进制数据，在内存中。
		2).验证，检查类的数据是否满足java的要求。
		3).准备，
		4).解析，将里面可以解析的符号进行解析。
		5).初始化，执行类中static域的赋值和static方法。
	4.如何热替换
		需要利用classloader。
		简单来说，在加载一个类时，需要使用用户自定义类加载器UserClassLoader来进行加载。修改了类的代码后，需要通过字节码生成技术重新生成类的class文件，然后舍去之前的类加载器，并新建一个UserClassLoader来进行加载。以前加载进来的类和类加载器将会被从内存中移除。
		参考jsp的class实时加载方案，每个jsp都将生成对应的java文件并会生成对应的字节码class文件，每个jsp-class文件都会用JasperLoader进行类加载，当jsp-class被修改会新建一个JasperLoader来加载新的jsp-class，而丢弃以前的。
	5.软引用和弱引用的区别
		软引用，当内存空间不足的时候，引用的对象才会gc标记并且清楚。
		弱引用，引用的对象只能活到下次gc。
	6.同类名不同jar包的类加载
	7.一个大量对象迅速产生又死亡的代码如何优化
五、数据结构与算法
	1.选择法排序
		基本思想是 每次遍历数组选择最小的值，然后将该值放到最前面。
		更进一步，第i次遍历，选择r[i+1]~r[n-1]中的最小值，并与r[i]进行交换，直至全部完毕。
	2.外部排序
		磁盘中可以存储的数据远大于内存，为了对磁盘中的海量数据进行排序，因此要使用外部排序。这里设内存可以放置的数据元素为N个。
		1).简单算法(两路合并)
			读取N个数据到内存中，进行排序并输出到磁盘中。这样可以将磁盘中的数据分为M组，每组N个元素的顺串保存到磁盘中。
			然后可以进行顺串的合并，两两长度为N的顺串合并后得到M/2组长度为2*N的顺串，按同样的方法再次进行排序，直到只有1组顺串为止。
			顺串合并采用归并排序是所用的合并方案。
		2).多路合并
			借鉴上述的方案，在得到初始的M组顺串后，使用k组顺串合并的方案，这样可以减少合并的次数，但是为了得到k个数的最小值会比2路的多花些时间。
		3).多相合并
			多相合并主要是为了节约磁盘空间。不展开。
		4).替换选择
			多路合并的方案需要读入N个元素到内存，然后输出一个长度为N的顺串。后面的合并操作主要受顺串的个数影响。
			为了进一步减小顺串的个数，可以考虑增大一个顺串的长度。
			N个元素读入到内存中并建立一个优先队列，执行一次deleteMin，把最小的元素输出到磁盘中。然后再读入一个元素到内存，若是比刚刚输出的元素大则将其入堆，若是比刚刚的输出元素小，则让它进死区，因为刚刚已经输出了比这个元素大的了，不能输出新加入的元素到磁盘中。
			一直如此，直到队列中没有元素时，便输出了一个顺串。此时死区已满，将死区中的数据重建堆，进行新的顺串输出。
	3.快速排序
		c++的stl采用的排序方法。
		基本思想是选取数组中的一个数，称为枢纽元。将数组中比枢纽元小的数分为1组，比枢纽元大的数分为1组，然后将这两组排序。排序得到两组数，可以直接拼接得到最终排序结果。
		枢纽元的选取方案；三数中值分割法，即选取左端 右端 中心位置上的3个元素的中值作为枢纽元。
	4.最长公共子序列
六、linux
	1.awk命令
	2.无法删除文件的原因 -> 没有写权限。
七、计算机网络
	1.三次握手
		客户端发送请求报文(SYN=1, seq=client_isn), client_isn是由客户端生成的序列号。
		服务端接收到请求报文后，将返回一个ACK报文(SYN=1, seq=server_isn, ack=client_isn+1)，server_isn是由服务器端生成的序列号。
		客户端收到ACK报文后，再返回一个ACK报文(SYN=0, seq=client_isn+1, ack=server_isn+1)
	2.四次挥手
		A发起FIN关闭请求，A端进入FIN_WAIT_1状态。
		B端收到FIN请求后回应ACK, A端进入FIN_WAIT_2状态，B端进入CLOSE_WAIT状态。
		B发起FIN请求，B端进入LAST_ACK状态。
		A端收到FIN请求后回应ACK，A端进入TIME_WAIT等待一段时间后，将进行关闭，B端收到ACK将关闭。
	3.TCP和UDP的区别
		1).TCP
		2).UDP
	4.TCP有哪些确保连接的机制
		1).三次握手
		2).滑动窗口机制协商队列大小实现数据传输
		3).超时重传
		4).CRC校验
		5).对于收到的请求，会进行回应
	5.HTTP头包含哪些内容
	6.http状态码(200 301 302 403 404 500)
		100-199 用于指定客户端应相应的某些动作。 
		200-299 用于表示请求成功。 
		300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 
		400-499 用于指出客户端的错误。 
		500-599 用于支持服务器错误。 
		
		200 : 请求已经成功。
		301 : 重定向。
		302 : 请求的资源现在临时从不同的 URI 响应请求。也是一个重定向。
		403 : 服务器已经理解请求，但是拒绝执行它。
		404 : 请求失败，请求所希望得到的资源未被在服务器上发现。
		500 : 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。
	7.HTTPS
		https服务器，就是服务器有个ssl证书，并且https协议的数据都是经过加密了的。
		简单来说，浏览器将自己的一套加密方案发送给服务器，服务器从中筛选出一组加密算法与hash算法，将自己的身份信息以证书的形式返回给浏览器。浏览器通过这些信息去验证服务器的合法性。
		若是合法，则从证书中获取公钥来进行传输数据的加密。
	8.DNS的原理
	9.cookie、session
	10.滑动窗口
	11.连接一个网址涉及到的操作
八、数据库
	1.mysql的数据库引擎
		1).MyISAM
			采用表锁，没有死锁危险，不具备事务功能。使用表时会将整个表的操作上读锁，可以同时读，但是不能同时写或同时读写。读操作大于更新操作时效率较高。
		2).Memory
			将数据保存在内存中。速度快，不能持久化。
		3).InnoDB
			采用行级锁，有死锁危险，采用事务管理。是mysql默认使用的数据库引擎。
	2.索引的结构和劣势
		不同的数据库与数据库引擎实现索引上有区别，对于mysql来说，Innodb的索引采用B+tree。
		1).空间劣势
			每创建一个索引，都要在磁盘中创建一份B+tree结构的索引文件，其key是索引字段，value是对应的主键。若主键字段过程，还会进一步消耗磁盘空间。
		2).增删改劣势
			当增删加一个条目时，会更新涉及到的所有索引文件的b+tree。
			当修改索引值时，也会更新对应的索引的b+tree。
		3).和主键索引的区别
			主键索引也是一个b+tree文件，key是主键，value是该条目的所有数据。普通的索引key是索引字段，value是对应的主键。
	3.crud的基本命令
		1).增: "insert into <table> (...) values (...)"
		2).删: "delete from <table> where ..."
		3).改: "update <table> set ... where ..."
		4).查: "select .. from <table> where ..."
	4.事务的acid
		1).原子性，一个事物是不可分割的最小单元，事务要么成功全部成功，要么全部失败。
		2).一致性，。
		3).隔离性，通常来说，一个事务所做的操作在未提交前，对其他事务来说是不可见的。这需要隔离级别【提交读】的支持。
		4).持久性，一旦事务提交，其修改将用于保存到数据库。
	5.事务隔离级别
		1).未提交读
			其他事务未提交的修改，会反应在当前数据中，被称为【脏读】
		2).提交读
			只要其他事务提交，其修改在当前事务是可以得到的。在当前事务中不能保证读取的全一样，因此会造成【不可重复读】。
		3).可重复读
			其他事务提交了所做的修改，不会反应到当前事务中，避免了【不可重复读】。但是其他事务添加的数据会反应到当前事务中，因此会幻读。
		4).可串行化
			事务的操作完全串行化，当开了一个事务时，就不能开其他事务了。其他事务会阻塞到当前事务提交。
	6.提高效率的sql用法
九、分布式与网络编程
	1.redis
	2.ngnix
	3.负载均衡原理
	4.RPC原理
	5.kafka
	6.mr
	7.elasticSearch
十、并发编程
	1.synchronized和lock的区别
	2.volatile的作用
		volatile为了保障与主内存交互的原子性，并且可以取消重排序优化。因此具有可见性。
		volatile声明的变量操作，都会从主内存中取数据，并将数据同步到主内存。非volatile变量，使用的是线程内存。
十一、操作系统
	1.进程和线程的区别
	2.进程间如何通讯
	3.线程间如何通讯
	4.进程的堆栈的区别
	5.进程和线程的执行力度的区别(这个问题问的是啥我都没弄懂)
十二、安全
	1.常用加密算法
		异或加密、DES、AES、RSA、椭圆加密、混沌加密。
	2.对称加密和非对称加密
		1).对称加密
			即传统的加密方式，加密解密使用同一个密钥。DES和AES是用的较多的对称加密方案。DES现在已经不够安全了。
		2).非对称加密(密钥对加密)
			即常见的用公钥私钥的加密方法，常用的有rsa加密和椭圆加密。
			非对称加密主要使用密钥对来完成操作，公钥加密的数据可以使用私钥解密，私钥加密的数据可以使用公钥解密。使用场景:
			a).传统加密传输
				A向B发送秘密信息，B将生成密钥对并将公钥发送给A，A使用公钥进行加密，然后将加密数据发送给B。
				https就是采用这也的机制，浏览器将数据使用公钥进行加密发送给服务器，由服务器来进行解密。
			b).身份认证
				A证实B的身份，B将生成密钥对将公钥发送给A，而后由B发送到A的操作均是通过私钥加密的，A将使用公钥将解密这个信息，若无法解析则无法证实B的身份，拒绝A的数据。
				github采用的就是该机制，github是角色A，本地仓库是角色B。github会使用所有的公钥来解析本地仓库发送过去的数据，若均无法解析则拒绝本地仓库的请求。